Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\UI\ControlBar.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\UI\EvalBar.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\UI\EvalTree.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\UI\HexController.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\UI\HexGrid.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\Database.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\AbstractAI.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\AbstractGame.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\BitArray.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\Chain.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\HexAI.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\HexBoard.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\HexBoardTree.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\HexGame.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\HexMove.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\HexTreeData.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\HexTreeNode.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\HexWeights.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Game\Hex\Template.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\HexCpp.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\main.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\x64\ReleaseWindows\rcc\qrc_HexCpp.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\x64\ReleaseWindows\moc\moc_HexCpp.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\x64\ReleaseWindows\moc\moc_HexGrid.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\x64\ReleaseWindows\moc\moc_HexController.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\x64\ReleaseWindows\moc\moc_EvalTree.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\x64\ReleaseWindows\moc\moc_EvalBar.cpp.
Error while processing C:\Users\nitzr\source\repos\HexCpp\HexCpp\x64\ReleaseWindows\moc\moc_ControlBar.cpp.
error: argument unused during compilation: '-Zc:externConstexpr' [clang-diagnostic-unused-command-line-argument]
error: argument unused during compilation: '-Zc:throwingNew' [clang-diagnostic-unused-command-line-argument]
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:704:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zLine, zTrans, nTrans);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:704:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zLine, zTrans, nTrans);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:818:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:818:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:863:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(p->z+p->n, zAppend, nAppend);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:863:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(p->z+p->n, zAppend, nAppend);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:863:5: warning: Null pointer passed as 1st argument to memory copy function [clang-analyzer-unix.cstring.NullArg]
    memcpy(p->z+p->n, zAppend, nAppend);
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18341:7: note: Assuming field 'pExpert' is null
  if( p->expert.pExpert ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18341:3: note: Taking false branch
  if( p->expert.pExpert ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Assuming the condition is true
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
         ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:3: note: Loop condition is true.  Entering loop body
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18349:12: note: Assuming the character is not a whitespace character
    while( IsSpace(zLine[h]) ){ h++; }
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:201:21: note: expanded from macro 'IsSpace'
#define IsSpace(X)  isspace((unsigned char)X)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18349:5: note: Loop condition is false. Execution continues on line 18350
    while( IsSpace(zLine[h]) ){ h++; }
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18350:5: note: Taking false branch
    if( zLine[h]==0 ) break;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:9: note: Assuming the condition is false
    if( zLine[h]=='\'' || zLine[h]=='"' ){
        ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:27: note: Assuming the condition is true
    if( zLine[h]=='\'' || zLine[h]=='"' ){
                          ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:5: note: Taking true branch
    if( zLine[h]=='\'' || zLine[h]=='"' ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:14: note: Assuming the condition is true
      while( zLine[h] && zLine[h]!=delim ){
             ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:14: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:26: note: Assuming the condition is false
      while( zLine[h] && zLine[h]!=delim ){
                         ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:7: note: Loop condition is false. Execution continues on line 18358
      while( zLine[h] && zLine[h]!=delim ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18358:7: note: Taking true branch
      if( zLine[h]==delim ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18361:7: note: Taking true branch
      if( delim=='"' ) resolve_backslashes(azArg[nArg-1]);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Assuming the condition is false
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
         ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:19: note: Left side of '&&' is false
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18373:7: note: 'nArg' is not equal to 0
  if( nArg==0 ) return 0; /* no tokens, no error */
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18373:3: note: Taking false branch
  if( nArg==0 ) return 0; /* no tokens, no error */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18379:7: note: Assuming the condition is false
  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18379:14: note: Left side of '&&' is false
  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18401:8: note: Assuming the condition is false
  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18401:15: note: Left side of '&&' is false
  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18402:8: note: Assuming the condition is false
   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18402:15: note: Left side of '&&' is false
   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18469:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18478:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "binary", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18491:7: note: Assuming the condition is false
  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18491:14: note: Left side of '&&' is false
  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18513:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18517:14: note: Left side of '&&' is false
  if( c=='c' && n>=3 && strncmp(azArg[0], "changes", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18530:14: note: Left side of '&&' is false
  if( c=='c' && n>=3 && strncmp(azArg[0], "check", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18551:14: note: Left side of '&&' is false
  if( c=='c' && strncmp(azArg[0], "clone", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18560:7: note: Assuming the condition is false
  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18560:14: note: Left side of '&&' is false
  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18598:14: note: Left side of '&&' is false
  if( c=='d' && n>=3 && strncmp(azArg[0], "dbconfig", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18637:14: note: Left side of '&&' is false
  if( c=='d' && n>=3 && strncmp(azArg[0], "dbinfo", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18648:14: note: Left side of '&&' is false
  if( c=='d' && strncmp(azArg[0], "dump", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:7: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18769:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18800:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18807:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18830:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "expert", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18836:7: note: Assuming the condition is false
  if( c=='f' && strncmp(azArg[0], "filectrl", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18836:14: note: Left side of '&&' is false
  if( c=='f' && strncmp(azArg[0], "filectrl", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18983:14: note: Left side of '&&' is false
  if( c=='f' && strncmp(azArg[0], "fullschema", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19032:7: note: Assuming the condition is false
  if( c=='h' && strncmp(azArg[0], "headers", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19032:14: note: Left side of '&&' is false
  if( c=='h' && strncmp(azArg[0], "headers", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19042:14: note: Left side of '&&' is false
  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19053:7: note: Assuming the condition is false
  if( c=='i' && strncmp(azArg[0], "import", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19053:14: note: Left side of '&&' is false
  if( c=='i' && strncmp(azArg[0], "import", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19329:14: note: Left side of '&&' is false
  if( c=='i' && strncmp(azArg[0], "imposter", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19452:7: note: Assuming the condition is false
  if( c=='l' && n>=5 && strncmp(azArg[0], "limits", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19452:14: note: Left side of '&&' is false
  if( c=='l' && n>=5 && strncmp(azArg[0], "limits", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19511:14: note: Left side of '&&' is false
  if( c=='l' && n>2 && strncmp(azArg[0], "lint", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19517:14: note: Left side of '&&' is false
  if( c=='l' && strncmp(azArg[0], "load", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19537:14: note: Left side of '&&' is false
  if( c=='l' && strncmp(azArg[0], "log", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19548:7: note: Assuming the condition is false
  if( c=='m' && strncmp(azArg[0], "mode", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19548:14: note: Left side of '&&' is false
  if( c=='m' && strncmp(azArg[0], "mode", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19608:7: note: Assuming the condition is false
  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19608:14: note: Left side of '&&' is false
  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19646:7: note: Assuming the condition is false
  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19646:14: note: Left side of '&&' is false
  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19715:9: note: Left side of '&&' is false
        && (strncmp(azArg[0], "output", n)==0||strncmp(azArg[0], "once", n)==0))
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19716:15: note: Left side of '&&' is false
   || (c=='e' && n==5 && strcmp(azArg[0],"excel")==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19822:7: note: Assuming the condition is false
  if( c=='p' && n>=3 && strncmp(azArg[0], "parameter", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19822:14: note: Left side of '&&' is false
  if( c=='p' && n>=3 && strncmp(azArg[0], "parameter", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19926:14: note: Left side of '&&' is false
  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19936:14: note: Left side of '&&' is false
  if( c=='p' && n>=3 && strncmp(azArg[0], "progress", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19981:14: note: Left side of '&&' is false
  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19990:7: note: Assuming the condition is false
  if( c=='q' && strncmp(azArg[0], "quit", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19990:14: note: Left side of '&&' is false
  if( c=='q' && strncmp(azArg[0], "quit", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19994:7: note: Assuming the condition is false
  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19994:14: note: Left side of '&&' is false
  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20028:14: note: Left side of '&&' is false
  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20079:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "scanstats", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20091:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "schema", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20231:14: note: Left side of '&&' is false
  if( c=='s' && n==11 && strncmp(azArg[0], "selecttrace", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20456:14: note: Left side of '&&' is false
  if( c=='s' && n>=4 && strncmp(azArg[0],"selftest",n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20562:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "separator", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20577:14: note: Left side of '&&' is false
  if( c=='s' && n>=4 && strncmp(azArg[0],"sha3sum",n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20693:4: note: Left side of '&&' is false
   && (strncmp(azArg[0], "shell", n)==0 || strncmp(azArg[0],"system",n)==0)
   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20713:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "show", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20756:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "stats", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20773:8: note: Assuming the condition is true
  if( (c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20773:8: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20773:18: note: Assuming 'n' is > 1
  if( (c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0)
                 ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20773:8: note: Left side of '&&' is true
  if( (c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0)
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20774:4: note: Left side of '||' is true
   || (c=='i' && (strncmp(azArg[0], "indices", n)==0
   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20782:5: note: Calling 'initText'
    initText(&s);
    ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:818:3: note: Null pointer value stored to 's.z'
  memset(p, 0, sizeof(*p));
  ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20782:5: note: Returning from 'initText'
    initText(&s);
    ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20785:9: note: Assuming 'rc' is 0
    if( rc ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20785:5: note: Taking false branch
    if( rc ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20790:9: note: 'nArg' is <= 2
    if( nArg>2 && c=='i' ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20790:16: note: Left side of '&&' is false
    if( nArg>2 && c=='i' ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20799:15: note: Assuming the condition is false
    for(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii++){
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20799:5: note: Loop condition is false. Execution continues on line 20821
    for(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20822:5: note: Calling 'appendText'
    appendText(&s, " ORDER BY 1", 0);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:839:7: note: 'quote' is 0
  if( quote ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:839:3: note: Taking false branch
  if( quote ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:846:7: note: Assuming the condition is false
  if( p->n+len>=p->nAlloc ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:846:3: note: Taking false branch
  if( p->n+len>=p->nAlloc ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:852:7: note: 'quote' is 0
  if( quote ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:852:3: note: Taking false branch
  if( quote ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:863:5: note: Null pointer passed as 1st argument to memory copy function
    memcpy(p->z+p->n, zAppend, nAppend);
    ^      ~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1228:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(value, 0, sizeof(value));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1228:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(value, 0, sizeof(value));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1256:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(dirp, 0, sizeof(DIR));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1256:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(dirp, 0, sizeof(DIR));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1263:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&data, 0, sizeof(struct _finddata_t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1263:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&data, 0, sizeof(struct _finddata_t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1276:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&data, 0, sizeof(struct _finddata_t));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1276:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&data, 0, sizeof(struct _finddata_t));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1287:3: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  strncpy(dirp->d_first.d_name, data.name, NAME_MAX);
  ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1287:3: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
  strncpy(dirp->d_first.d_name, data.name, NAME_MAX);
  ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1312:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&data, 0, sizeof(struct _finddata_t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1312:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&data, 0, sizeof(struct _finddata_t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1320:3: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  strncpy(dirp->d_next.d_name, data.name, NAME_MAX);
  ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1320:3: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
  strncpy(dirp->d_next.d_name, data.name, NAME_MAX);
  ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1344:5: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    strncpy(entry->d_name, dirp->d_first.d_name, NAME_MAX);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1344:5: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
    strncpy(entry->d_name, dirp->d_first.d_name, NAME_MAX);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1353:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&data, 0, sizeof(struct _finddata_t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1353:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&data, 0, sizeof(struct _finddata_t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1364:3: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  strncpy(entry->d_name, data.name, NAME_MAX);
  ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1364:3: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
  strncpy(entry->d_name, data.name, NAME_MAX);
  ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1799:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1799:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:1834:38: warning: performing pointer subtraction with a null pointer has undefined behavior [clang-diagnostic-null-pointer-subtraction]
  if( (p->nLoaded % 8)==0 && ((aData - (const unsigned char*)0)&7)==0 ){
                                     ^ ~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2041:13: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memcpy(&u, &v, 8);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2041:13: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
            memcpy(&u, &v, 8);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2055:13: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memcpy(&u, &r, 8);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2055:13: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
            memcpy(&u, &r, 8);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2334:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&epochSystemTime, 0, sizeof(SYSTEMTIME));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2334:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&epochSystemTime, 0, sizeof(SYSTEMTIME));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2363:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&fd, 0, sizeof(WIN32_FIND_DATAW));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2363:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&fd, 0, sizeof(WIN32_FIND_DATAW));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2709:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pNew, 0, sizeof(*pNew));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2709:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pNew, 0, sizeof(*pNew));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2732:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pCur, 0, sizeof(*pCur));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2732:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pCur, 0, sizeof(*pCur));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2800:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&aNew[pCur->nLvl], 0, sizeof(FsdirLevel)*(nNew-pCur->nLvl));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:2800:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&aNew[pCur->nLvl], 0, sizeof(FsdirLevel)*(nNew-pCur->nLvl));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:3256:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pNew, 0, sizeof(*pNew));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:3256:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pNew, 0, sizeof(*pNew));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:3277:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pCur, 0, sizeof(*pCur));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:3277:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pCur, 0, sizeof(*pCur));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:3888:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:3888:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4153:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pApndFile, 0, sizeof(ApndFile));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4153:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pApndFile, 0, sizeof(ApndFile));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4172:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(pApndFile, pBaseFile, pBaseVfs->szOsFile);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4172:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
    memmove(pApndFile, pBaseFile, pBaseVfs->szOsFile);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4405:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&memtraceBase, 0, sizeof(memtraceBase));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4405:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&memtraceBase, 0, sizeof(memtraceBase));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4655:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(p->a+p->nDigit, 0, iExp);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4655:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(p->a+p->nDigit, 0, iExp);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4674:7: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memmove(p->a+iExp, p->a, p->nDigit);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4674:7: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
      memmove(p->a+iExp, p->a, p->nDigit);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4675:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(p->a, 0, iExp);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4675:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(p->a, 0, iExp);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4837:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(p->a+nAddSig, p->a, p->nDigit);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4837:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
    memmove(p->a+nAddSig, p->a, p->nDigit);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4838:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p->a, 0, nAddSig);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4838:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p->a, 0, nAddSig);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4842:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p->a+p->nDigit, 0, nAddFrac);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:4842:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p->a+p->nDigit, 0, nAddFrac);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5069:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(acc, 0, pA->nDigit + pB->nDigit + 2);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5069:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(acc, 0, pA->nDigit + pB->nDigit + 2);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5269:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&r, &v, sizeof(r));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5269:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&r, &v, sizeof(r));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5279:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&a,&r,sizeof(a));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5279:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&a,&r,sizeof(a));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5343:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
      m >>= 1-e;
        ^   ~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5253:7: note: Assuming 'argc' is not equal to 1
  if( argc==1 ){
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5253:3: note: Taking false branch
  if( argc==1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5318:9: note: Assuming 'e' is <= 10000
    if( e>10000 ){
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5318:5: note: Taking false branch
    if( e>10000 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5320:15: note: Assuming the condition is true
    }else if( e<-10000 ){
              ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5320:11: note: Taking true branch
    }else if( e<-10000 ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5324:9: note: Assuming 'm' is >= 0
    if( m<0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5324:5: note: Taking false branch
    if( m<0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5328:15: note: Assuming 'm' is equal to 0
    }else if( m==0 && e>-1000 && e<1000 ){
              ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5328:15: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5328:31: note: Left side of '&&' is false
    }else if( m==0 && e>-1000 && e<1000 ){
                              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5332:5: note: Loop condition is false. Execution continues on line 5336
    while( (m>>32)&0xffe00000 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5336:12: note: 'm' is equal to 0
    while( m!=0 && ((m>>32)&0xfff00000)==0 ){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5336:17: note: Left side of '&&' is false
    while( m!=0 && ((m>>32)&0xfff00000)==0 ){
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5341:9: note: 'e' is <= 0
    if( e<=0 ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5341:5: note: Taking true branch
    if( e<=0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5343:9: note: Assigned value is garbage or undefined
      m >>= 1-e;
        ^   ~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5351:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&r, &a, sizeof(r));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5351:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&r, &a, sizeof(r));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5375:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&r, &v, sizeof(r));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5375:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&r, &v, sizeof(r));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5392:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&v, &r, sizeof(r));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5392:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&v, &r, sizeof(r));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5570:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pNew, 0, sizeof(*pNew));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5570:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pNew, 0, sizeof(*pNew));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5592:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pCur, 0, sizeof(*pCur));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5592:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pCur, 0, sizeof(*pCur));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5876:15: warning: Dereference of null pointer (loaded from variable 'pzErrMsg') [clang-analyzer-core.NullDereference]
    *pzErrMsg = sqlite3_mprintf(
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21863:7: note: Assuming the environment variable does not exist
  if( getenv("SQLITE_DEBUG_BREAK") ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21863:3: note: Taking false branch
  if( getenv("SQLITE_DEBUG_BREAK") ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21884:3: note: Taking false branch
  if( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,60)!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21903:7: note: Assuming 'argv' is not equal to null
  if( argv==0 ) shell_out_of_memory();
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21903:3: note: Taking false branch
  if( argv==0 ) shell_out_of_memory();
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21904:12: note: Assuming 'i' is >= 'argc'
  for(i=0; i<argc; i++){
           ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21904:3: note: Loop condition is false. Execution continues on line 21915
  for(i=0; i<argc; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21948:12: note: 'i' is >= 'argc'
  for(i=1; i<argc; i++){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21948:3: note: Loop condition is false. Execution continues on line 22065
  for(i=1; i<argc; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22083:7: note: 'zVfs' is null
  if( zVfs ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22083:3: note: Taking false branch
  if( zVfs ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22093:7: note: Assuming field 'zDbFilename' is not equal to null
  if( data.zDbFilename==0 ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22093:3: note: Taking false branch
  if( data.zDbFilename==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22110:7: note: Assuming the condition is true
  if( access(data.zDbFilename, 0)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:165:24: note: expanded from macro 'access'
#   define access(f,m) _access((f),(m))
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22110:3: note: Taking true branch
  if( access(data.zDbFilename, 0)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22111:5: note: Calling 'open_db'
    open_db(&data, 0);
    ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15508:7: note: Assuming field 'db' is equal to null
  if( p->db==0 ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15508:3: note: Taking true branch
  if( p->db==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15509:9: note: Assuming field 'openMode' is not equal to SHELL_OPEN_UNSPEC
    if( p->openMode==SHELL_OPEN_UNSPEC ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15509:5: note: Taking false branch
    if( p->openMode==SHELL_OPEN_UNSPEC ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15517:5: note: Control jumps to 'case 3:'  at line 15528
    switch( p->openMode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15530:9: note:  Execution continues on line 15544
        break;
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15545:9: note: Assuming field 'db' is not equal to null
    if( p->db==0 || SQLITE_OK!=sqlite3_errcode(p->db) ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15545:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15545:21: note: Assuming the condition is false
    if( p->db==0 || SQLITE_OK!=sqlite3_errcode(p->db) ){
                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database/SQLite/sqlite3.h:421:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15545:5: note: Taking false branch
    if( p->db==0 || SQLITE_OK!=sqlite3_errcode(p->db) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15564:32: note: Passing null pointer value via 2nd parameter 'pzErrMsg'
    sqlite3_series_init(p->db, 0, 0);
                               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15564:5: note: Calling 'sqlite3_series_init'
    sqlite3_series_init(p->db, 0, 0);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5875:7: note: Assuming the condition is true
  if( sqlite3_libversion_number()<3008012 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5875:3: note: Taking true branch
  if( sqlite3_libversion_number()<3008012 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:5876:15: note: Dereference of null pointer (loaded from variable 'pzErrMsg')
    *pzErrMsg = sqlite3_mprintf(
     ~~~~~~~~ ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:6266:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&p->aOp[p->nState], &p->aOp[iStart], N*sizeof(p->aOp[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:6266:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&p->aOp[p->nState], &p->aOp[iStart], N*sizeof(p->aOp[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:6267:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&p->aArg[p->nState], &p->aArg[iStart], N*sizeof(p->aArg[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:6267:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&p->aArg[p->nState], &p->aArg[iStart], N*sizeof(p->aArg[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:6526:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pRe, 0, sizeof(*pRe));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:6526:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pRe, 0, sizeof(*pRe));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9326:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pRet, 0, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9326:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pRet, 0, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9337:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pHash, 0, sizeof(IdxHash));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9337:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pHash, 0, sizeof(IdxHash));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9354:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pHash, 0, sizeof(IdxHash));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9354:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pHash, 0, sizeof(IdxHash));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9394:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pEntry->zKey, zKey, nKey);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9394:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pEntry->zKey, zKey, nKey);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9397:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pEntry->zVal, zVal, nVal);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9397:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pEntry->zVal, zVal, nVal);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9450:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pNew->zColl, zColl, nColl+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9450:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pNew->zColl, zColl, nColl+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9882:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pCsr, zCol, nCopy);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9882:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pCsr, zCol, nCopy);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9891:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pCsr, zCol, nCopy);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9891:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pCsr, zCol, nCopy);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9903:17: warning: Access to field 'zName' results in a dereference of a null pointer (loaded from variable 'pNew') [clang-analyzer-core.NullDereference]
    pNew->zName = pCsr;
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18341:7: note: Assuming field 'pExpert' is null
  if( p->expert.pExpert ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18341:3: note: Taking false branch
  if( p->expert.pExpert ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Assuming the condition is true
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
         ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:3: note: Loop condition is true.  Entering loop body
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18349:12: note: Assuming the character is not a whitespace character
    while( IsSpace(zLine[h]) ){ h++; }
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:201:21: note: expanded from macro 'IsSpace'
#define IsSpace(X)  isspace((unsigned char)X)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18349:5: note: Loop condition is false. Execution continues on line 18350
    while( IsSpace(zLine[h]) ){ h++; }
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18350:5: note: Taking false branch
    if( zLine[h]==0 ) break;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:9: note: Assuming the condition is false
    if( zLine[h]=='\'' || zLine[h]=='"' ){
        ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:27: note: Assuming the condition is true
    if( zLine[h]=='\'' || zLine[h]=='"' ){
                          ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:5: note: Taking true branch
    if( zLine[h]=='\'' || zLine[h]=='"' ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:14: note: Assuming the condition is true
      while( zLine[h] && zLine[h]!=delim ){
             ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:14: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:26: note: Assuming the condition is false
      while( zLine[h] && zLine[h]!=delim ){
                         ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:7: note: Loop condition is false. Execution continues on line 18358
      while( zLine[h] && zLine[h]!=delim ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18358:7: note: Taking true branch
      if( zLine[h]==delim ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18361:7: note: Taking true branch
      if( delim=='"' ) resolve_backslashes(azArg[nArg-1]);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Assuming the condition is false
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
         ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:19: note: Left side of '&&' is false
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18373:7: note: 'nArg' is not equal to 0
  if( nArg==0 ) return 0; /* no tokens, no error */
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18373:3: note: Taking false branch
  if( nArg==0 ) return 0; /* no tokens, no error */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18379:7: note: Assuming the condition is false
  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18379:14: note: Left side of '&&' is false
  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18401:8: note: Assuming the condition is false
  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18401:15: note: Left side of '&&' is false
  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18402:8: note: Assuming the condition is false
   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18402:15: note: Left side of '&&' is false
   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18469:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18478:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "binary", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18491:7: note: Assuming the condition is false
  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18491:14: note: Left side of '&&' is false
  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18513:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18517:14: note: Left side of '&&' is false
  if( c=='c' && n>=3 && strncmp(azArg[0], "changes", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18530:14: note: Left side of '&&' is false
  if( c=='c' && n>=3 && strncmp(azArg[0], "check", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18551:14: note: Left side of '&&' is false
  if( c=='c' && strncmp(azArg[0], "clone", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18560:7: note: Assuming the condition is false
  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18560:14: note: Left side of '&&' is false
  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18598:14: note: Left side of '&&' is false
  if( c=='d' && n>=3 && strncmp(azArg[0], "dbconfig", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18637:14: note: Left side of '&&' is false
  if( c=='d' && n>=3 && strncmp(azArg[0], "dbinfo", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18648:14: note: Left side of '&&' is false
  if( c=='d' && strncmp(azArg[0], "dump", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:7: note: Assuming the condition is true
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:17: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:3: note: Taking false branch
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18769:7: note: Left side of '&&' is true
  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18769:17: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18769:3: note: Taking false branch
  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18800:7: note: Left side of '&&' is true
  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18800:17: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18800:3: note: Taking false branch
  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18807:7: note: Left side of '&&' is true
  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18807:17: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18807:3: note: Taking false branch
  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18830:7: note: Left side of '&&' is true
  if( c=='e' && strncmp(azArg[0], "expert", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18830:3: note: Taking true branch
  if( c=='e' && strncmp(azArg[0], "expert", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18832:5: note: Calling 'expertDotCommand'
    expertDotCommand(p, azArg, nArg);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14304:12: note: 'rc' is equal to SQLITE_OK
  for(i=1; rc==SQLITE_OK && i<nArg; i++){
           ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14304:12: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14304:3: note: Loop condition is false. Execution continues on line 14330
  for(i=1; rc==SQLITE_OK && i<nArg; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14330:7: note: 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14330:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14331:30: note: Calling 'sqlite3_expert_new'
    pState->expert.pExpert = sqlite3_expert_new(pState->db, &zErr);
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10916:7: note: 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10916:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10921:7: note: Assuming 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10921:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10923:9: note: Assuming 'rc' is equal to SQLITE_OK
    if( rc==SQLITE_OK ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10923:5: note: Taking true branch
    if( rc==SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10930:7: note: 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10930:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10936:12: note: Assuming 'rc' is equal to SQLITE_OK
    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
           ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10936:12: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10936:29: note: Assuming the condition is false
    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database/SQLite/sqlite3.h:451:28: note: expanded from macro 'SQLITE_ROW'
#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10936:5: note: Loop condition is false. Execution continues on line 10940
    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10944:7: note: Assuming 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10944:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10945:10: note: Calling 'idxCreateVtabSchema'
    rc = idxCreateVtabSchema(pNew, pzErrmsg);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10498:10: note: 'rc' is equal to SQLITE_OK
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) ){
         ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10498:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10498:27: note: Assuming the condition is true
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) ){
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database/SQLite/sqlite3.h:451:28: note: expanded from macro 'SQLITE_ROW'
#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10498:3: note: Loop condition is true.  Entering loop body
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10503:9: note: Assuming the condition is false
    if( zType[0]=='v' || zType[1]=='r' ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10503:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10503:26: note: Assuming the condition is false
    if( zType[0]=='v' || zType[1]=='r' ){
                         ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10503:5: note: Taking false branch
    if( zType[0]=='v' || zType[1]=='r' ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10507:12: note: Calling 'idxGetTableInfo'
      rc = idxGetTableInfo(p->db, zName, &pTab, pzErrmsg);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9847:3: note: 'pNew' initialized to a null pointer value
  IdxTable *pNew = 0;
  ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9853:10: note: Assuming 'rc' is not equal to SQLITE_OK
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
         ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9853:24: note: Left side of '&&' is false
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9864:7: note: 'rc' is not equal to SQLITE_OK
  if( rc==SQLITE_OK ) rc = rc2;
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9864:3: note: Taking false branch
  if( rc==SQLITE_OK ) rc = rc2;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9867:7: note: 'rc' is not equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9867:3: note: Taking false branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9870:7: note: 'rc' is not equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9870:3: note: Taking false branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9877:10: note: 'rc' is not equal to SQLITE_OK
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
         ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9877:24: note: Left side of '&&' is false
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9899:7: note: Assuming 'rc' is equal to SQLITE_OK
  if( rc!=SQLITE_OK ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9899:3: note: Taking false branch
  if( rc!=SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9903:17: note: Access to field 'zName' results in a dereference of a null pointer (loaded from variable 'pNew')
    pNew->zName = pCsr;
    ~~~~        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9904:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pNew->zName, zTab, nTab+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9904:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pNew->zName, zTab, nTab+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9904:5: warning: Null pointer passed as 1st argument to memory copy function [clang-analyzer-unix.cstring.NullArg]
    memcpy(pNew->zName, zTab, nTab+1);
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18341:7: note: Assuming field 'pExpert' is null
  if( p->expert.pExpert ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18341:3: note: Taking false branch
  if( p->expert.pExpert ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Assuming the condition is true
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
         ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:3: note: Loop condition is true.  Entering loop body
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18349:12: note: Assuming the character is not a whitespace character
    while( IsSpace(zLine[h]) ){ h++; }
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:201:21: note: expanded from macro 'IsSpace'
#define IsSpace(X)  isspace((unsigned char)X)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18349:5: note: Loop condition is false. Execution continues on line 18350
    while( IsSpace(zLine[h]) ){ h++; }
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18350:5: note: Taking false branch
    if( zLine[h]==0 ) break;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:9: note: Assuming the condition is false
    if( zLine[h]=='\'' || zLine[h]=='"' ){
        ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:27: note: Assuming the condition is true
    if( zLine[h]=='\'' || zLine[h]=='"' ){
                          ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:5: note: Taking true branch
    if( zLine[h]=='\'' || zLine[h]=='"' ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:14: note: Assuming the condition is true
      while( zLine[h] && zLine[h]!=delim ){
             ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:14: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:26: note: Assuming the condition is false
      while( zLine[h] && zLine[h]!=delim ){
                         ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:7: note: Loop condition is false. Execution continues on line 18358
      while( zLine[h] && zLine[h]!=delim ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18358:7: note: Taking true branch
      if( zLine[h]==delim ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18361:7: note: Taking true branch
      if( delim=='"' ) resolve_backslashes(azArg[nArg-1]);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Assuming the condition is false
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
         ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:19: note: Left side of '&&' is false
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18373:7: note: 'nArg' is not equal to 0
  if( nArg==0 ) return 0; /* no tokens, no error */
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18373:3: note: Taking false branch
  if( nArg==0 ) return 0; /* no tokens, no error */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18379:7: note: Assuming the condition is false
  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18379:14: note: Left side of '&&' is false
  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18401:8: note: Assuming the condition is false
  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18401:15: note: Left side of '&&' is false
  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18402:8: note: Assuming the condition is false
   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18402:15: note: Left side of '&&' is false
   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18469:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18478:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "binary", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18491:7: note: Assuming the condition is false
  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18491:14: note: Left side of '&&' is false
  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18513:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18517:14: note: Left side of '&&' is false
  if( c=='c' && n>=3 && strncmp(azArg[0], "changes", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18530:14: note: Left side of '&&' is false
  if( c=='c' && n>=3 && strncmp(azArg[0], "check", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18551:14: note: Left side of '&&' is false
  if( c=='c' && strncmp(azArg[0], "clone", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18560:7: note: Assuming the condition is false
  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18560:14: note: Left side of '&&' is false
  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18598:14: note: Left side of '&&' is false
  if( c=='d' && n>=3 && strncmp(azArg[0], "dbconfig", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18637:14: note: Left side of '&&' is false
  if( c=='d' && n>=3 && strncmp(azArg[0], "dbinfo", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18648:14: note: Left side of '&&' is false
  if( c=='d' && strncmp(azArg[0], "dump", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:7: note: Assuming the condition is true
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:17: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:3: note: Taking false branch
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18769:7: note: Left side of '&&' is true
  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18769:17: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18769:3: note: Taking false branch
  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18800:7: note: Left side of '&&' is true
  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18800:17: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18800:3: note: Taking false branch
  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18807:7: note: Left side of '&&' is true
  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18807:17: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18807:3: note: Taking false branch
  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18830:7: note: Left side of '&&' is true
  if( c=='e' && strncmp(azArg[0], "expert", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18830:3: note: Taking true branch
  if( c=='e' && strncmp(azArg[0], "expert", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18832:5: note: Calling 'expertDotCommand'
    expertDotCommand(p, azArg, nArg);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14304:12: note: 'rc' is equal to SQLITE_OK
  for(i=1; rc==SQLITE_OK && i<nArg; i++){
           ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14304:12: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14304:3: note: Loop condition is false. Execution continues on line 14330
  for(i=1; rc==SQLITE_OK && i<nArg; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14330:7: note: 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14330:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14331:30: note: Calling 'sqlite3_expert_new'
    pState->expert.pExpert = sqlite3_expert_new(pState->db, &zErr);
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10916:7: note: 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10916:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10921:7: note: Assuming 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10921:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10923:9: note: Assuming 'rc' is equal to SQLITE_OK
    if( rc==SQLITE_OK ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10923:5: note: Taking true branch
    if( rc==SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10930:7: note: 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10930:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10936:12: note: Assuming 'rc' is equal to SQLITE_OK
    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
           ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10936:12: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10936:29: note: Assuming the condition is false
    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database/SQLite/sqlite3.h:451:28: note: expanded from macro 'SQLITE_ROW'
#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10936:5: note: Loop condition is false. Execution continues on line 10940
    while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10944:7: note: Assuming 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10944:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10945:10: note: Calling 'idxCreateVtabSchema'
    rc = idxCreateVtabSchema(pNew, pzErrmsg);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10498:10: note: 'rc' is equal to SQLITE_OK
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) ){
         ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10498:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10498:27: note: Assuming the condition is true
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) ){
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database/SQLite/sqlite3.h:451:28: note: expanded from macro 'SQLITE_ROW'
#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10498:3: note: Loop condition is true.  Entering loop body
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10503:9: note: Assuming the condition is false
    if( zType[0]=='v' || zType[1]=='r' ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10503:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10503:26: note: Assuming the condition is false
    if( zType[0]=='v' || zType[1]=='r' ){
                         ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10503:5: note: Taking false branch
    if( zType[0]=='v' || zType[1]=='r' ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10507:12: note: Calling 'idxGetTableInfo'
      rc = idxGetTableInfo(p->db, zName, &pTab, pzErrmsg);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9849:3: note: 'pCsr' initialized to a null pointer value
  char *pCsr = 0;
  ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9853:10: note: Assuming 'rc' is equal to SQLITE_OK
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
         ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9853:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9853:27: note: Assuming the condition is false
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database/SQLite/sqlite3.h:451:28: note: expanded from macro 'SQLITE_ROW'
#define SQLITE_ROW         100  /* sqlite3_step() has another row ready */
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9853:3: note: Loop condition is false. Execution continues on line 9863
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9864:7: note: 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ) rc = rc2;
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9864:3: note: Taking true branch
  if( rc==SQLITE_OK ) rc = rc2;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9867:7: note: Assuming 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9867:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9870:7: note: Assuming 'rc' is not equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9870:3: note: Taking false branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9877:10: note: 'rc' is not equal to SQLITE_OK
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
         ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9877:24: note: Left side of '&&' is false
  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9899:7: note: Assuming 'rc' is equal to SQLITE_OK
  if( rc!=SQLITE_OK ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9899:3: note: Taking false branch
  if( rc!=SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9903:5: note: Null pointer value stored to field 'zName'
    pNew->zName = pCsr;
    ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9904:5: note: Null pointer passed as 1st argument to memory copy function
    memcpy(pNew->zName, zTab, nTab+1);
    ^      ~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9934:17: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      if( nIn ) memcpy(zRet, zIn, nIn);
                ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9934:17: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      if( nIn ) memcpy(zRet, zIn, nIn);
                ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9935:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&zRet[nIn], zAppend, nAppend+1);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:9935:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&zRet[nIn], zAppend, nAppend+1);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10652:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(pSlot->z, sqlite3_value_blob(argv[1]), nByte);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10652:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(pSlot->z, sqlite3_value_blob(argv[1]), nByte);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10654:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(pSlot->z, sqlite3_value_text(argv[1]), nByte);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:10654:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(pSlot->z, sqlite3_value_text(argv[1]), nByte);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:11012:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(pNew->zSql, z, n+1);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:11012:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(pNew->zSql, z, n+1);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12342:7: warning: Value stored to 'j' is never read [clang-analyzer-deadcode.DeadStores]
      j = sz;
      ^   ~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12342:7: note: Value stored to 'j' is never read
      j = sz;
      ^   ~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12372:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p->colSepPrior, p->colSeparator, sizeof(p->colSeparator));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12372:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(p->colSepPrior, p->colSeparator, sizeof(p->colSeparator));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12373:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p->rowSepPrior, p->rowSeparator, sizeof(p->rowSeparator));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12373:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(p->rowSepPrior, p->rowSeparator, sizeof(p->rowSeparator));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12378:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p->colSeparator, p->colSepPrior, sizeof(p->colSeparator));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12378:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(p->colSeparator, p->colSepPrior, sizeof(p->colSeparator));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12379:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p->rowSeparator, p->rowSepPrior, sizeof(p->rowSeparator));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12379:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(p->rowSeparator, p->rowSepPrior, sizeof(p->rowSeparator));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12795:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pNew->zText, zText, nText+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12795:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pNew->zText, zText, nText+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12815:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&p->sGraph, 0, sizeof(p->sGraph));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12815:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&p->sGraph, 0, sizeof(p->sGraph));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12840:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&p->sGraph.zPrefix[n], pNext ? "|  " : "   ", 4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:12840:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&p->sGraph.zPrefix[n], pNext ? "|  " : "   ", 4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:13165:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&ur,&r,sizeof(r));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:13165:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&ur,&r,sizeof(r));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:13168:23: warning: comparison of integers of different signs: 'sqlite3_uint64' (aka 'unsigned long long') and 'long long' [clang-diagnostic-sign-compare]
          }else if( ur==0xfff0000000000000LL ){
                    ~~^ ~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:13206:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&ur,&r,sizeof(r));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:13206:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&ur,&r,sizeof(r));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:13209:23: warning: comparison of integers of different signs: 'sqlite3_uint64' (aka 'unsigned long long') and 'long long' [clang-diagnostic-sign-compare]
          }else if( ur==0xfff0000000000000LL ){
                    ~~^ ~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:13458:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zErrMsg, sqlite3_errmsg(db), nErrMsg);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:13458:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zErrMsg, sqlite3_errmsg(db), nErrMsg);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14027:12: warning: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc' [clang-analyzer-deadcode.DeadStores]
  }while( (rc = sqlite3_step(pStmt))==SQLITE_ROW );
           ^    ~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14027:12: note: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc'
  }while( (rc = sqlite3_step(pStmt))==SQLITE_ROW );
           ^    ~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14035:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p->actualWidth, 0, nColumn*sizeof(int));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14035:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p->actualWidth, 0, nColumn*sizeof(int));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14171:7: warning: Value stored to 'rc' is never read [clang-analyzer-deadcode.DeadStores]
      rc = SQLITE_NOMEM;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14171:7: note: Value stored to 'rc' is never read
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14302:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pState->expert, 0, sizeof(ExpertInfo));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:14302:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pState->expert, 0, sizeof(ExpertInfo));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15279:8: warning: Call to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  rc = sscanf(zLine, "| size %d pagesize %d", &n, &pgsz);
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15279:8: note: Call to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11
  rc = sscanf(zLine, "| size %d pagesize %d", &n, &pgsz);
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15289:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(a, 0, n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15289:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(a, 0, n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15295:10: warning: Call to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    rc = sscanf(zLine, "| page %d offset %d", &j, &k);
         ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15295:10: note: Call to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11
    rc = sscanf(zLine, "| page %d offset %d", &j, &k);
         ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15303:10: warning: Call to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    rc = sscanf(zLine,"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x",
         ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15303:10: note: Call to function 'sscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sscanf_s' in case of C11
    rc = sscanf(zLine,"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x",
         ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15451:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&zOut[iOut], "replace(replace(", 16);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15451:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&zOut[iOut], "replace(replace(", 16);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15454:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&zOut[iOut], "replace(", 8);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15454:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&zOut[iOut], "replace(", 8);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15459:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&zOut[iOut], zNL, nNL);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15459:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&zOut[iOut], zNL, nNL);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15462:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&zOut[iOut], zCR, nCR);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15462:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&zOut[iOut], zCR, nCR);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15471:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&zOut[iOut], ",'", 2); iOut += 2;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15471:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&zOut[iOut], ",'", 2); iOut += 2;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15472:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&zOut[iOut], zNL, nNL); iOut += nNL;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15472:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&zOut[iOut], zNL, nNL); iOut += nNL;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15473:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&zOut[iOut], "', char(10))", 12); iOut += 12;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15473:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&zOut[iOut], "', char(10))", 12); iOut += 12;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15476:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&zOut[iOut], ",'", 2); iOut += 2;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15476:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&zOut[iOut], ",'", 2); iOut += 2;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15477:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&zOut[iOut], zCR, nCR); iOut += nCR;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15477:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&zOut[iOut], zCR, nCR); iOut += nCR;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15478:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&zOut[iOut], "', char(13))", 12); iOut += 12;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15478:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&zOut[iOut], "', char(13))", 12); iOut += 12;
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:15888:14: warning: variable 'nCall' set but not used [clang-diagnostic-unused-but-set-variable]
  static int nCall = 0;
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16093:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zInsert+i, ",?", 2);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16093:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zInsert+i, ",?", 2);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16096:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(zInsert+i, ");", 3);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16096:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(zInsert+i, ");", 3);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16221:13: warning: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc' [clang-analyzer-deadcode.DeadStores]
    while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){
            ^    ~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16221:13: note: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc'
    while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){
            ^    ~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16389:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(aHdr, sqlite3_column_blob(pStmt,0), 100);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16389:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(aHdr, sqlite3_column_blob(pStmt,0), 100);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18986:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&data, p, sizeof(data));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18986:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&data, p, sizeof(data));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19069:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sCtx, 0, sizeof(sCtx));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19069:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sCtx, 0, sizeof(sCtx));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19372:5: warning: Value stored to 'rc' is never read [clang-analyzer-deadcode.DeadStores]
    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19372:5: note: Value stored to 'rc' is never read
    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
    ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19851:9: warning: Value stored to 'rx' is never read [clang-analyzer-deadcode.DeadStores]
        rx = sqlite3_prepare_v2(p->db,
        ^    ~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19851:9: note: Value stored to 'rx' is never read
        rx = sqlite3_prepare_v2(p->db,
        ^    ~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19983:7: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19983:7: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
      strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19986:7: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19986:7: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
      strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20103:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&data, p, sizeof(data));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20103:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&data, p, sizeof(data));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20821:5: warning: Value stored to 'rc' is never read [clang-analyzer-deadcode.DeadStores]
    rc = sqlite3_finalize(pStmt);
    ^    ~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20821:5: note: Value stored to 'rc' is never read
    rc = sqlite3_finalize(pStmt);
    ^    ~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21341:19: warning: Call to 'realloc' has an allocation size of 0 bytes [clang-analyzer-optin.portability.UnixAPI]
    p->colWidth = realloc(p->colWidth, p->nWidth*sizeof(int)*2);
                  ^                    ~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18341:7: note: Assuming field 'pExpert' is null
  if( p->expert.pExpert ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18341:3: note: Taking false branch
  if( p->expert.pExpert ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Assuming the condition is true
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
         ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:3: note: Loop condition is true.  Entering loop body
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18349:12: note: Assuming the character is not a whitespace character
    while( IsSpace(zLine[h]) ){ h++; }
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:201:21: note: expanded from macro 'IsSpace'
#define IsSpace(X)  isspace((unsigned char)X)
                    ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18349:5: note: Loop condition is false. Execution continues on line 18350
    while( IsSpace(zLine[h]) ){ h++; }
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18350:5: note: Taking false branch
    if( zLine[h]==0 ) break;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:9: note: Assuming the condition is false
    if( zLine[h]=='\'' || zLine[h]=='"' ){
        ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:27: note: Assuming the condition is true
    if( zLine[h]=='\'' || zLine[h]=='"' ){
                          ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18351:5: note: Taking true branch
    if( zLine[h]=='\'' || zLine[h]=='"' ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:14: note: Assuming the condition is true
      while( zLine[h] && zLine[h]!=delim ){
             ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:14: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:26: note: Assuming the condition is false
      while( zLine[h] && zLine[h]!=delim ){
                         ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18354:7: note: Loop condition is false. Execution continues on line 18358
      while( zLine[h] && zLine[h]!=delim ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18358:7: note: Taking true branch
      if( zLine[h]==delim ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18361:7: note: Taking true branch
      if( delim=='"' ) resolve_backslashes(azArg[nArg-1]);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:10: note: Assuming the condition is false
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
         ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18348:19: note: Left side of '&&' is false
  while( zLine[h] && nArg<ArraySize(azArg)-1 ){
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18373:7: note: 'nArg' is not equal to 0
  if( nArg==0 ) return 0; /* no tokens, no error */
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18373:3: note: Taking false branch
  if( nArg==0 ) return 0; /* no tokens, no error */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18376:3: note: Calling 'clearTempFile'
  clearTempFile(p);
  ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16572:7: note: Assuming field 'zTempFile' is equal to null
  if( p->zTempFile==0 ) return;
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16572:3: note: Taking true branch
  if( p->zTempFile==0 ) return;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:16572:25: note: Returning without writing to 'p->nWidth'
  if( p->zTempFile==0 ) return;
                        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18376:3: note: Returning from 'clearTempFile'
  clearTempFile(p);
  ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18379:7: note: Assuming the condition is false
  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18379:14: note: Left side of '&&' is false
  if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18401:8: note: Assuming the condition is false
  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18401:15: note: Left side of '&&' is false
  if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18402:8: note: Assuming the condition is false
   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18402:15: note: Left side of '&&' is false
   || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18469:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18478:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "binary", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18491:7: note: Assuming the condition is false
  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18491:14: note: Left side of '&&' is false
  if( c=='c' && strcmp(azArg[0],"cd")==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18513:14: note: Left side of '&&' is false
  if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18517:14: note: Left side of '&&' is false
  if( c=='c' && n>=3 && strncmp(azArg[0], "changes", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18530:14: note: Left side of '&&' is false
  if( c=='c' && n>=3 && strncmp(azArg[0], "check", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18551:14: note: Left side of '&&' is false
  if( c=='c' && strncmp(azArg[0], "clone", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18560:7: note: Assuming the condition is false
  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18560:14: note: Left side of '&&' is false
  if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18598:14: note: Left side of '&&' is false
  if( c=='d' && n>=3 && strncmp(azArg[0], "dbconfig", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18637:14: note: Left side of '&&' is false
  if( c=='d' && n>=3 && strncmp(azArg[0], "dbinfo", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18648:14: note: Left side of '&&' is false
  if( c=='d' && strncmp(azArg[0], "dump", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:7: note: Assuming the condition is false
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18760:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18769:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18800:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18807:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18830:14: note: Left side of '&&' is false
  if( c=='e' && strncmp(azArg[0], "expert", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18836:7: note: Assuming the condition is false
  if( c=='f' && strncmp(azArg[0], "filectrl", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18836:14: note: Left side of '&&' is false
  if( c=='f' && strncmp(azArg[0], "filectrl", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:18983:14: note: Left side of '&&' is false
  if( c=='f' && strncmp(azArg[0], "fullschema", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19032:7: note: Assuming the condition is false
  if( c=='h' && strncmp(azArg[0], "headers", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19032:14: note: Left side of '&&' is false
  if( c=='h' && strncmp(azArg[0], "headers", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19042:14: note: Left side of '&&' is false
  if( c=='h' && strncmp(azArg[0], "help", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19053:7: note: Assuming the condition is false
  if( c=='i' && strncmp(azArg[0], "import", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19053:14: note: Left side of '&&' is false
  if( c=='i' && strncmp(azArg[0], "import", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19329:14: note: Left side of '&&' is false
  if( c=='i' && strncmp(azArg[0], "imposter", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19452:7: note: Assuming the condition is false
  if( c=='l' && n>=5 && strncmp(azArg[0], "limits", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19452:14: note: Left side of '&&' is false
  if( c=='l' && n>=5 && strncmp(azArg[0], "limits", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19511:14: note: Left side of '&&' is false
  if( c=='l' && n>2 && strncmp(azArg[0], "lint", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19517:14: note: Left side of '&&' is false
  if( c=='l' && strncmp(azArg[0], "load", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19537:14: note: Left side of '&&' is false
  if( c=='l' && strncmp(azArg[0], "log", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19548:7: note: Assuming the condition is false
  if( c=='m' && strncmp(azArg[0], "mode", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19548:14: note: Left side of '&&' is false
  if( c=='m' && strncmp(azArg[0], "mode", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19608:7: note: Assuming the condition is false
  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19608:14: note: Left side of '&&' is false
  if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19646:7: note: Assuming the condition is false
  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19646:14: note: Left side of '&&' is false
  if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19715:9: note: Left side of '&&' is false
        && (strncmp(azArg[0], "output", n)==0||strncmp(azArg[0], "once", n)==0))
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19716:15: note: Left side of '&&' is false
   || (c=='e' && n==5 && strcmp(azArg[0],"excel")==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19822:7: note: Assuming the condition is false
  if( c=='p' && n>=3 && strncmp(azArg[0], "parameter", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19822:14: note: Left side of '&&' is false
  if( c=='p' && n>=3 && strncmp(azArg[0], "parameter", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19926:14: note: Left side of '&&' is false
  if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19936:14: note: Left side of '&&' is false
  if( c=='p' && n>=3 && strncmp(azArg[0], "progress", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19981:14: note: Left side of '&&' is false
  if( c=='p' && strncmp(azArg[0], "prompt", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19990:7: note: Assuming the condition is false
  if( c=='q' && strncmp(azArg[0], "quit", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19990:14: note: Left side of '&&' is false
  if( c=='q' && strncmp(azArg[0], "quit", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19994:7: note: Assuming the condition is false
  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:19994:14: note: Left side of '&&' is false
  if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20028:14: note: Left side of '&&' is false
  if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20079:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "scanstats", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20091:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "schema", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20231:14: note: Left side of '&&' is false
  if( c=='s' && n==11 && strncmp(azArg[0], "selecttrace", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20456:14: note: Left side of '&&' is false
  if( c=='s' && n>=4 && strncmp(azArg[0],"selftest",n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20562:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "separator", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20577:14: note: Left side of '&&' is false
  if( c=='s' && n>=4 && strncmp(azArg[0],"sha3sum",n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20693:4: note: Left side of '&&' is false
   && (strncmp(azArg[0], "shell", n)==0 || strncmp(azArg[0],"system",n)==0)
   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20713:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "show", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20756:14: note: Left side of '&&' is false
  if( c=='s' && strncmp(azArg[0], "stats", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20773:8: note: Assuming the condition is false
  if( (c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0)
       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20773:15: note: Left side of '&&' is false
  if( (c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20774:15: note: Left side of '&&' is false
   || (c=='i' && (strncmp(azArg[0], "indices", n)==0
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20880:14: note: Left side of '&&' is false
  if( c=='t' && strcmp(azArg[0],"testcase")==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:20894:14: note: Left side of '&&' is false
  if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21113:14: note: Left side of '&&' is false
  if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21118:14: note: Left side of '&&' is false
  if( c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21132:14: note: Left side of '&&' is false
  if( c=='t' && strncmp(azArg[0], "trace", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21269:7: note: Assuming the condition is false
  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21269:14: note: Left side of '&&' is false
  if( c=='v' && strncmp(azArg[0], "version", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21288:14: note: Left side of '&&' is false
  if( c=='v' && strncmp(azArg[0], "vfsinfo", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21302:14: note: Left side of '&&' is false
  if( c=='v' && strncmp(azArg[0], "vfslist", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21320:14: note: Left side of '&&' is false
  if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21332:7: note: Assuming the condition is true
  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21332:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21332:17: note: Assuming the condition is false
  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21332:3: note: Taking false branch
  if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21337:7: note: Left side of '&&' is true
  if( c=='w' && strncmp(azArg[0], "width", n)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21337:3: note: Taking true branch
  if( c=='w' && strncmp(azArg[0], "width", n)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21340:5: note: The value 0 is assigned to field 'nWidth'
    p->nWidth = nArg-1;
    ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21341:19: note: Call to 'realloc' has an allocation size of 0 bytes
    p->colWidth = realloc(p->colWidth, p->nWidth*sizeof(int)*2);
                  ^                    ~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21526:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zLine,";",2);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21526:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zLine,";",2);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21539:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zSql, zLine+i, nLine+1-i);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21539:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zSql, zLine+i, nLine+1-i);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21539:7: warning: Null pointer passed as 1st argument to memory copy function [clang-analyzer-unix.cstring.NullArg]
      memcpy(zSql, zLine+i, nLine+1-i);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21863:7: note: Assuming the environment variable does not exist
  if( getenv("SQLITE_DEBUG_BREAK") ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21863:3: note: Taking false branch
  if( getenv("SQLITE_DEBUG_BREAK") ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21884:3: note: Taking false branch
  if( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,60)!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21903:7: note: Assuming 'argv' is not equal to null
  if( argv==0 ) shell_out_of_memory();
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21903:3: note: Taking false branch
  if( argv==0 ) shell_out_of_memory();
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21904:12: note: Assuming 'i' is >= 'argc'
  for(i=0; i<argc; i++){
           ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21904:3: note: Loop condition is false. Execution continues on line 21915
  for(i=0; i<argc; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21948:12: note: 'i' is >= 'argc'
  for(i=1; i<argc; i++){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21948:3: note: Loop condition is false. Execution continues on line 22065
  for(i=1; i<argc; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22083:7: note: 'zVfs' is null
  if( zVfs ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22083:3: note: Taking false branch
  if( zVfs ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22093:7: note: Assuming field 'zDbFilename' is not equal to null
  if( data.zDbFilename==0 ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22093:3: note: Taking false branch
  if( data.zDbFilename==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22110:7: note: Assuming the condition is false
  if( access(data.zDbFilename, 0)==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:165:24: note: expanded from macro 'access'
#   define access(f,m) _access((f),(m))
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22110:3: note: Taking false branch
  if( access(data.zDbFilename, 0)==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22118:3: note: Calling 'process_sqliterc'
  process_sqliterc(&data,zInitFile);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21655:7: note: 'sqliterc' is equal to NULL
  if (sqliterc == NULL) {
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21655:3: note: Taking true branch
  if (sqliterc == NULL) {
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21657:9: note: 'home_dir' is not equal to null
    if( home_dir==0 ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21657:5: note: Taking false branch
    if( home_dir==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21666:7: note: Assuming field 'in' is non-null
  if( p->in ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21666:3: note: Taking true branch
  if( p->in ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21667:9: note: Assuming 'stdin_is_interactive' is 0
    if( stdin_is_interactive ){
        ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21667:5: note: Taking false branch
    if( stdin_is_interactive ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21670:9: note: Calling 'process_input'
    if( process_input(p) && bail_on_error ) exit(1);
        ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21486:3: note: 'zSql' initialized to a null pointer value
  char *zSql = 0;           /* Accumulated SQL text */
  ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21496:10: note: 'errCnt' is equal to 0
  while( errCnt==0 || !bail_on_error || (p->in==0 && stdin_is_interactive) ){
         ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21496:20: note: Left side of '||' is true
  while( errCnt==0 || !bail_on_error || (p->in==0 && stdin_is_interactive) ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21498:13: note: Calling 'one_input_line'
    zLine = one_input_line(p->in, zLine, nSql>0);
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:729:7: note: 'in' is not equal to null
  if( in!=0 ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:729:3: note: Taking true branch
  if( in!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:730:15: note: Calling 'local_getline'
    zResult = local_getline(zPrior, in);
              ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:668:15: note: 'zLine' is equal to null
  int nLine = zLine==0 ? 0 : 100;
              ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:668:15: note: '?' condition is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:671:3: note: Loop condition is true.  Entering loop body
  while( 1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:672:5: note: Taking true branch
    if( n+100>nLine ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:675:11: note: Assuming 'zLine' is not equal to null, which participates in a condition later
      if( zLine==0 ) shell_out_of_memory();
          ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:675:7: note: Taking false branch
      if( zLine==0 ) shell_out_of_memory();
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:677:9: note: Assigning value, which participates in a condition later
    if( fgets(&zLine[n], nLine - n, in)==0 ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:677:9: note: Assuming the condition is false
    if( fgets(&zLine[n], nLine - n, in)==0 ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:677:5: note: Taking false branch
    if( fgets(&zLine[n], nLine - n, in)==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:685:5: note: Loop condition is true.  Entering loop body
    while( zLine[n] ) n++;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:685:5: note: Loop condition is true.  Entering loop body
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:685:5: note: Loop condition is false. Execution continues on line 686
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:686:9: note: 'n' is > 0
    if( n>0 && zLine[n-1]=='\n' ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:686:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:686:16: note: Assuming the condition is true
    if( n>0 && zLine[n-1]=='\n' ){
               ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:686:5: note: Taking true branch
    if( n>0 && zLine[n-1]=='\n' ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:688:11: note: 'n' is > 0
      if( n>0 && zLine[n-1]=='\r' ) n--;
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:688:11: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:688:18: note: Assuming the condition is false
      if( n>0 && zLine[n-1]=='\r' ) n--;
                 ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:688:7: note: Taking false branch
      if( n>0 && zLine[n-1]=='\r' ) n--;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:690:7: note:  Execution continues on line 696
      break;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:696:7: note: 'stdin_is_interactive' is 0
  if( stdin_is_interactive && in==stdin ){
      ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:696:28: note: Left side of '&&' is false
  if( stdin_is_interactive && in==stdin ){
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:709:3: note: Returning pointer (loaded from 'zLine'), which participates in a condition later
  return zLine;
  ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:730:15: note: Returning from 'local_getline'
    zResult = local_getline(zPrior, in);
              ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:743:3: note: Returning pointer (loaded from 'zResult'), which participates in a condition later
  return zResult;
  ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21498:13: note: Returning from 'one_input_line'
    zLine = one_input_line(p->in, zLine, nSql>0);
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21499:9: note: 'zLine' is not equal to null
    if( zLine==0 ){
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21499:5: note: Taking false branch
    if( zLine==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21504:9: note: Assuming 'seenInterrupt' is 0
    if( seenInterrupt ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21504:5: note: Taking false branch
    if( seenInterrupt ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21509:9: note: 'nSql' is equal to 0
    if( nSql==0 && _all_whitespace(zLine) ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21509:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21509:5: note: Taking false branch
    if( nSql==0 && _all_whitespace(zLine) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21513:9: note: 'zLine' is non-null
    if( zLine && (zLine[0]=='.' || zLine[0]=='#') && nSql==0 ){
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21513:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21513:19: note: Assuming the condition is false
    if( zLine && (zLine[0]=='.' || zLine[0]=='#') && nSql==0 ){
                  ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21513:19: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21513:36: note: Assuming the condition is false
    if( zLine && (zLine[0]=='.' || zLine[0]=='#') && nSql==0 ){
                                   ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21513:51: note: Left side of '&&' is false
    if( zLine && (zLine[0]=='.' || zLine[0]=='#') && nSql==0 ){
                                                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21525:43: note: Left side of '&&' is false
    if( line_is_command_terminator(zLine) && line_is_complete(zSql, nSql) ){
                                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21529:9: note: Assuming the condition is false
    if( nSql+nLine+2>=nAlloc ){
        ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21529:5: note: Taking false branch
    if( nSql+nLine+2>=nAlloc ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21535:9: note: 'nSql' is equal to 0
    if( nSql==0 ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21535:5: note: Taking true branch
    if( nSql==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21537:16: note: Left side of '&&' is true
      for(i=0; zLine[i] && IsSpace(zLine[i]); i++){}
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21537:7: note: Loop condition is false. Execution continues on line 21538
      for(i=0; zLine[i] && IsSpace(zLine[i]); i++){}
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21539:7: note: Null pointer passed as 1st argument to memory copy function
      memcpy(zSql, zLine+i, nLine+1-i);
      ^      ~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21544:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zSql+nSql, zLine, nLine+1);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21544:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zSql+nSql, zLine, nLine+1);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21632:13: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    if( z ) memcpy(z, home_dir, n);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21632:13: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    if( z ) memcpy(z, home_dir, n);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21771:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(data, 0, sizeof(*data));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21771:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(data, 0, sizeof(*data));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21774:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(data->colSeparator,SEP_Column, 2);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21774:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(data->colSeparator,SEP_Column, 2);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21775:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(data->rowSeparator,SEP_Row, 2);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21775:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(data->rowSeparator,SEP_Row, 2);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21911:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(argv[i], z, n+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:21911:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(argv[i], z, n+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22153:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(data.colSeparator,",",2);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22153:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(data.colSeparator,",",2);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22379:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&data, 0, sizeof(data));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\shell.c:22379:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&data, 0, sizeof(data));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:22413:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:22413:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:22734:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sLocal, 0, sizeof(sLocal));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:22734:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sLocal, 0, sizeof(sLocal));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:22970:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(&tx, 0, sizeof(tx));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:22970:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(&tx, 0, sizeof(tx));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23054:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23054:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23519:10: warning: Access to field 'xWrite' results in a dereference of a null pointer (loaded from field 'pMethods') [clang-analyzer-core.NullDereference]
  return id->pMethods->xWrite(id, pBuf, amt, offset);
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76954:7: note: Assuming field 'pMethods' is null
  if( pFd->pMethods ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76954:3: note: Taking false branch
  if( pFd->pMethods ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76978:3: note: Calling 'sqlite3_backup_step'
  sqlite3_backup_step(&b, 0x7FFFFFFF);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76555:10: note: Field 'pDestDb' is null
  if( p->pDestDb ){
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76555:3: note: Taking false branch
  if( p->pDestDb ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76560:3: note: Taking true branch
  if( !isFatalError(rc) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76570:12: note: Field 'pDestDb' is null
    if( p->pDestDb && p->pSrc->pBt->inTransaction==TRANS_WRITE ){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76570:20: note: Left side of '&&' is false
    if( p->pDestDb && p->pSrc->pBt->inTransaction==TRANS_WRITE ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76580:9: note: 'rc' is equal to SQLITE_OK
    if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76580:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76580:26: note: Assuming the condition is false
    if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:7362:26: note: expanded from macro 'SQLITE_TXN_NONE'
#define SQLITE_TXN_NONE  0
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76580:5: note: Taking false branch
    if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:12: note: Field 'bDestLocked' is equal to 0
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:9: note: Left side of '&&' is true
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:30: note: 'rc' is equal to SQLITE_OK
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
                             ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:9: note: Left side of '&&' is true
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:47: note: Assuming the condition is false
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:5: note: Taking false branch
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:20: note: 'rc' is equal to SQLITE_OK
    if( SQLITE_OK==rc && p->bDestLocked==0
                   ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:9: note: Left side of '&&' is true
    if( SQLITE_OK==rc && p->bDestLocked==0
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:1503:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:29: note: Field 'bDestLocked' is equal to 0
    if( SQLITE_OK==rc && p->bDestLocked==0
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:9: note: Left side of '&&' is true
    if( SQLITE_OK==rc && p->bDestLocked==0
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:1503:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76597:9: note: Assuming the condition is false
     && SQLITE_OK==(rc = sqlite3BtreeBeginTrans(p->pDest, 2,
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:1503:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:5: note: Taking false branch
    if( SQLITE_OK==rc && p->bDestLocked==0
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76608:20: note: 'rc' is not equal to SQLITE_OK
    if( SQLITE_OK==rc && destMode==PAGER_JOURNALMODE_WAL && pgszSrc!=pgszDest ){
                   ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76608:23: note: Left side of '&&' is false
    if( SQLITE_OK==rc && destMode==PAGER_JOURNALMODE_WAL && pgszSrc!=pgszDest ){
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:16: note: 'nPage' is >= 0
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
               ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:16: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:27: note: 'ii' is < 'nPage'
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
                          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:15: note: Left side of '&&' is true
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:40: note: Assuming 'nSrcPage' is < field 'iNext'
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
                                       ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:65: note: Left side of '&&' is false
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
                                                                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76629:9: note: 'rc' is not equal to SQLITE_OK
    if( rc==SQLITE_OK ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76629:5: note: Taking false branch
    if( rc==SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76644:9: note: Assuming 'rc' is equal to SQLITE_DONE
    if( rc==SQLITE_DONE ){
        ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76644:5: note: Taking true branch
    if( rc==SQLITE_DONE ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76645:11: note: Assuming 'nSrcPage' is not equal to 0
      if( nSrcPage==0 ){
          ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76645:7: note: Taking false branch
      if( nSrcPage==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76649:11: note: 'rc' is not equal to SQLITE_OK
      if( rc==SQLITE_OK || rc==SQLITE_DONE ){
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76649:11: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76649:28: note: 'rc' is equal to SQLITE_DONE
      if( rc==SQLITE_OK || rc==SQLITE_DONE ){
                           ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76649:7: note: Taking true branch
      if( rc==SQLITE_OK || rc==SQLITE_DONE ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76652:11: note: 'rc' is equal to SQLITE_OK
      if( rc==SQLITE_OK ){
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76652:7: note: Taking true branch
      if( rc==SQLITE_OK ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76653:13: note: Assuming field 'pDestDb' is null
        if( p->pDestDb ){
            ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76653:9: note: Taking false branch
        if( p->pDestDb ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76656:13: note: Assuming 'destMode' is not equal to PAGER_JOURNALMODE_WAL
        if( destMode==PAGER_JOURNALMODE_WAL ){
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76656:9: note: Taking false branch
        if( destMode==PAGER_JOURNALMODE_WAL ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76660:11: note: 'rc' is equal to SQLITE_OK
      if( rc==SQLITE_OK ){
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76660:7: note: Taking true branch
      if( rc==SQLITE_OK ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76676:13: note: Assuming 'pgszSrc' is < 'pgszDest'
        if( pgszSrc<pgszDest ){
            ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76676:9: note: Taking true branch
        if( pgszSrc<pgszDest ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76679:15: note: Assuming the condition is false
          if( nDestTruncate==(int)PENDING_BYTE_PAGE(p->pDest->pBt) ){
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76679:11: note: Taking false branch
          if( nDestTruncate==(int)PENDING_BYTE_PAGE(p->pDest->pBt) ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76687:13: note: 'pgszSrc' is < 'pgszDest'
        if( pgszSrc<pgszDest ){
            ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76687:9: note: Taking true branch
        if( pgszSrc<pgszDest ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76718:34: note: 'rc' is equal to SQLITE_OK
          for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){
                                 ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76718:34: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76718:51: note: Assuming 'iPg' is > 'nDstPage'
          for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){
                                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76718:11: note: Loop condition is false. Execution continues on line 76728
          for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76728:15: note: 'rc' is equal to SQLITE_OK
          if( rc==SQLITE_OK ){
              ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76728:11: note: Taking true branch
          if( rc==SQLITE_OK ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76733:18: note: Assuming the condition is false
          iEnd = MIN(PENDING_BYTE + pgszDest, iSize);
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14476:20: note: expanded from macro 'MIN'
# define MIN(A,B) ((A)<(B)?(A):(B))
                   ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76733:18: note: '?' condition is false
          iEnd = MIN(PENDING_BYTE + pgszDest, iSize);
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14476:20: note: expanded from macro 'MIN'
# define MIN(A,B) ((A)<(B)?(A):(B))
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76736:13: note: Assuming 'rc' is equal to SQLITE_OK
            rc==SQLITE_OK && iOff<iEnd;
            ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76736:13: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76736:30: note: Assuming 'iOff' is < 'iEnd'
            rc==SQLITE_OK && iOff<iEnd;
                             ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76734:11: note: Loop condition is true.  Entering loop body
          for(
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76742:17: note: Assuming 'rc' is equal to SQLITE_OK
            if( rc==SQLITE_OK ){
                ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76742:13: note: Taking true branch
            if( rc==SQLITE_OK ){
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76744:20: note: Calling 'sqlite3OsWrite'
              rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23519:10: note: Access to field 'xWrite' results in a dereference of a null pointer (loaded from field 'pMethods')
  return id->pMethods->xWrite(id, pBuf, amt, offset);
         ^   ~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23530:10: warning: Access to field 'xFileSize' results in a dereference of a null pointer (loaded from field 'pMethods') [clang-analyzer-core.NullDereference]
  return id->pMethods->xFileSize(id, pSize);
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76954:7: note: Assuming field 'pMethods' is null
  if( pFd->pMethods ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76954:3: note: Taking false branch
  if( pFd->pMethods ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76978:3: note: Calling 'sqlite3_backup_step'
  sqlite3_backup_step(&b, 0x7FFFFFFF);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76555:10: note: Field 'pDestDb' is null
  if( p->pDestDb ){
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76555:3: note: Taking false branch
  if( p->pDestDb ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76560:3: note: Taking true branch
  if( !isFatalError(rc) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76570:12: note: Field 'pDestDb' is null
    if( p->pDestDb && p->pSrc->pBt->inTransaction==TRANS_WRITE ){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76570:20: note: Left side of '&&' is false
    if( p->pDestDb && p->pSrc->pBt->inTransaction==TRANS_WRITE ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76580:9: note: 'rc' is equal to SQLITE_OK
    if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76580:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76580:26: note: Assuming the condition is false
    if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:7362:26: note: expanded from macro 'SQLITE_TXN_NONE'
#define SQLITE_TXN_NONE  0
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76580:5: note: Taking false branch
    if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:12: note: Field 'bDestLocked' is equal to 0
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:9: note: Left side of '&&' is true
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:30: note: 'rc' is equal to SQLITE_OK
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
                             ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:9: note: Left side of '&&' is true
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:47: note: Assuming the condition is false
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76591:5: note: Taking false branch
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:20: note: 'rc' is equal to SQLITE_OK
    if( SQLITE_OK==rc && p->bDestLocked==0
                   ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:9: note: Left side of '&&' is true
    if( SQLITE_OK==rc && p->bDestLocked==0
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:1503:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:29: note: Field 'bDestLocked' is equal to 0
    if( SQLITE_OK==rc && p->bDestLocked==0
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:9: note: Left side of '&&' is true
    if( SQLITE_OK==rc && p->bDestLocked==0
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:1503:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76597:9: note: Assuming the condition is false
     && SQLITE_OK==(rc = sqlite3BtreeBeginTrans(p->pDest, 2,
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:1503:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76596:5: note: Taking false branch
    if( SQLITE_OK==rc && p->bDestLocked==0
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76608:20: note: 'rc' is not equal to SQLITE_OK
    if( SQLITE_OK==rc && destMode==PAGER_JOURNALMODE_WAL && pgszSrc!=pgszDest ){
                   ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76608:23: note: Left side of '&&' is false
    if( SQLITE_OK==rc && destMode==PAGER_JOURNALMODE_WAL && pgszSrc!=pgszDest ){
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:16: note: 'nPage' is >= 0
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
               ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:16: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:27: note: 'ii' is < 'nPage'
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
                          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:15: note: Left side of '&&' is true
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:40: note: Assuming 'nSrcPage' is < field 'iNext'
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
                                       ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76617:65: note: Left side of '&&' is false
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
                                                                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76629:9: note: 'rc' is not equal to SQLITE_OK
    if( rc==SQLITE_OK ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76629:5: note: Taking false branch
    if( rc==SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76644:9: note: Assuming 'rc' is equal to SQLITE_DONE
    if( rc==SQLITE_DONE ){
        ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76644:5: note: Taking true branch
    if( rc==SQLITE_DONE ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76645:11: note: Assuming 'nSrcPage' is not equal to 0
      if( nSrcPage==0 ){
          ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76645:7: note: Taking false branch
      if( nSrcPage==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76649:11: note: 'rc' is not equal to SQLITE_OK
      if( rc==SQLITE_OK || rc==SQLITE_DONE ){
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76649:11: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76649:28: note: 'rc' is equal to SQLITE_DONE
      if( rc==SQLITE_OK || rc==SQLITE_DONE ){
                           ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76649:7: note: Taking true branch
      if( rc==SQLITE_OK || rc==SQLITE_DONE ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76652:11: note: 'rc' is equal to SQLITE_OK
      if( rc==SQLITE_OK ){
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76652:7: note: Taking true branch
      if( rc==SQLITE_OK ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76653:13: note: Assuming field 'pDestDb' is null
        if( p->pDestDb ){
            ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76653:9: note: Taking false branch
        if( p->pDestDb ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76656:13: note: Assuming 'destMode' is not equal to PAGER_JOURNALMODE_WAL
        if( destMode==PAGER_JOURNALMODE_WAL ){
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76656:9: note: Taking false branch
        if( destMode==PAGER_JOURNALMODE_WAL ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76660:11: note: 'rc' is equal to SQLITE_OK
      if( rc==SQLITE_OK ){
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76660:7: note: Taking true branch
      if( rc==SQLITE_OK ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76676:13: note: Assuming 'pgszSrc' is < 'pgszDest'
        if( pgszSrc<pgszDest ){
            ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76676:9: note: Taking true branch
        if( pgszSrc<pgszDest ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76679:15: note: Assuming the condition is false
          if( nDestTruncate==(int)PENDING_BYTE_PAGE(p->pDest->pBt) ){
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76679:11: note: Taking false branch
          if( nDestTruncate==(int)PENDING_BYTE_PAGE(p->pDest->pBt) ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76687:13: note: 'pgszSrc' is < 'pgszDest'
        if( pgszSrc<pgszDest ){
            ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76687:9: note: Taking true branch
        if( pgszSrc<pgszDest ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76718:34: note: 'rc' is equal to SQLITE_OK
          for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){
                                 ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76718:34: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76718:51: note: Assuming 'iPg' is > 'nDstPage'
          for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){
                                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76718:11: note: Loop condition is false. Execution continues on line 76728
          for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76728:15: note: 'rc' is equal to SQLITE_OK
          if( rc==SQLITE_OK ){
              ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76728:11: note: Taking true branch
          if( rc==SQLITE_OK ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76733:18: note: Assuming the condition is false
          iEnd = MIN(PENDING_BYTE + pgszDest, iSize);
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14476:20: note: expanded from macro 'MIN'
# define MIN(A,B) ((A)<(B)?(A):(B))
                   ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76733:18: note: '?' condition is false
          iEnd = MIN(PENDING_BYTE + pgszDest, iSize);
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14476:20: note: expanded from macro 'MIN'
# define MIN(A,B) ((A)<(B)?(A):(B))
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76736:13: note: Assuming 'rc' is equal to SQLITE_OK
            rc==SQLITE_OK && iOff<iEnd;
            ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76736:13: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76736:30: note: Assuming 'iOff' is >= 'iEnd'
            rc==SQLITE_OK && iOff<iEnd;
                             ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76734:11: note: Loop condition is false. Execution continues on line 76748
          for(
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76748:15: note: 'rc' is equal to SQLITE_OK
          if( rc==SQLITE_OK ){
              ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76748:11: note: Taking true branch
          if( rc==SQLITE_OK ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76749:18: note: Calling 'backupTruncateFile'
            rc = backupTruncateFile(pFile, iSize);
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76521:12: note: Calling 'sqlite3OsFileSize'
  int rc = sqlite3OsFileSize(pFile, &iCurrent);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23530:10: note: Access to field 'xFileSize' results in a dereference of a null pointer (loaded from field 'pMethods')
  return id->pMethods->xFileSize(id, pSize);
         ^   ~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23696:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(zBufOut, 0, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23696:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(zBufOut, 0, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23698:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zBufOut, &sqlite3Config.iPrngSeed, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:23698:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zBufOut, &sqlite3Config.iPrngSeed, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:27956:23: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));
                      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:27956:23: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));
                      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:27976:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&mem0, 0, sizeof(mem0));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:27976:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&mem0, 0, sizeof(mem0));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28317:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p, 0, (size_t)n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28317:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p, 0, (size_t)n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28330:11: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  if( p ) memset(p, 0, (size_t)n);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28330:11: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  if( p ) memset(p, 0, (size_t)n);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28457:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(pNew, p, lookasideMallocSize(db, p));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28457:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(pNew, p, lookasideMallocSize(db, p));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28504:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zNew, z, n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28504:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zNew, z, n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28515:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zNew, z, (size_t)n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28515:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zNew, z, (size_t)n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29167:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&u, &rx, sizeof(u));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29167:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&u, &rx, sizeof(u));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29190:13: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memcpy(buf+(prefix!=0),"Inf",4);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29190:13: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
            memcpy(buf+(prefix!=0),"Inf",4);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29568:42: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      if( !isMalloced(p) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);
                                         ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29568:42: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      if( !isMalloced(p) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);
                                         ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29603:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&p->zText[p->nChar], z, N);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29603:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&p->zText[p->nChar], z, N);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29603:5: warning: Null pointer passed as 2nd argument to memory copy function [clang-analyzer-unix.cstring.NullArg]
    memcpy(&p->zText[p->nChar], z, N);
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28871:3: note: Null pointer value stored to 'bufpt'
  bufpt = 0;
  ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28872:7: note: Assuming the condition is false
  if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28872:3: note: Taking false branch
  if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28878:9: note: Assuming the condition is true
  for(; (c=(*fmt))!=0; ++fmt){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28878:3: note: Loop condition is true.  Entering loop body
  for(; (c=(*fmt))!=0; ++fmt){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28879:9: note: Assuming the condition is false
    if( c!='%' ){
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28879:5: note: Taking false branch
    if( c!='%' ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28889:9: note: Assuming the condition is false
    if( (c=(*++fmt))==0 ){
        ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28889:5: note: Taking false branch
    if( (c=(*++fmt))==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28901:7: note: Control jumps to the 'default' case at line 28909
      switch( c ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28909:47: note:  Execution continues on line 28995
        default:    done = 1;                 break;
                                              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28995:14: note: 'done' is 1
    }while( !done && (c=(*++fmt))!=0 );
             ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28995:19: note: Left side of '&&' is false
    }while( !done && (c=(*++fmt))!=0 );
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28900:5: note: Loop condition is false.  Exiting loop
    do{
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29000:5: note: Loop condition is true.  Entering loop body
    for(idx=0; idx<ArraySize(fmtinfo); idx++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29001:11: note: Assuming 'c' is equal to field 'fmttype'
      if( c==fmtinfo[idx].fmttype ){
          ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29001:7: note: Taking true branch
      if( c==fmtinfo[idx].fmttype ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29004:9: note:  Execution continues on line 29025
        break;
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29027:5: note: Control jumps to 'case 4:'  at line 29306
    switch( xtype ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29307:14: note: 'bArgList' is 0
        if( !bArgList ){
             ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29307:9: note: Taking true branch
        if( !bArgList ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29308:13: note: Left side of '||' is false
          *(va_arg(ap,int*)) = pAccum->nChar;
            ^
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\stdarg.h:21:18: note: expanded from macro 'va_arg'
#define va_arg   __crt_va_arg
                 ^
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vadefs.h:159:11: note: expanded from macro '__crt_va_arg'
        ((sizeof(t) > sizeof(__int64) || (sizeof(t) & (sizeof(t) - 1)) != 0) \
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29308:13: note: '?' condition is false
          *(va_arg(ap,int*)) = pAccum->nChar;
            ^
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\stdarg.h:21:18: note: expanded from macro 'va_arg'
#define va_arg   __crt_va_arg
                 ^
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vadefs.h:159:10: note: expanded from macro '__crt_va_arg'
        ((sizeof(t) > sizeof(__int64) || (sizeof(t) & (sizeof(t) - 1)) != 0) \
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29311:9: note:  Execution continues on line 29511
        break;
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29512:9: note: 'width' is <= 0
    if( width>0 ){
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29512:5: note: Taking false branch
    if( width>0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29517:34: note: Passing null pointer value via 2nd parameter 'z'
      sqlite3_str_append(pAccum, bufpt, length);
                                 ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29517:7: note: Calling 'sqlite3_str_append'
      sqlite3_str_append(pAccum, bufpt, length);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29617:7: note: Assuming the condition is true
  if( p->nChar+N >= p->nAlloc ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29617:3: note: Taking true branch
  if( p->nChar+N >= p->nAlloc ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29618:24: note: Passing null pointer value via 2nd parameter 'z'
    enlargeAndAppend(p,z,N);
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29618:5: note: Calling 'enlargeAndAppend'
    enlargeAndAppend(p,z,N);
    ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29602:7: note: Assuming 'N' is > 0
  if( N>0 ){
      ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29602:3: note: Taking true branch
  if( N>0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29603:5: note: Null pointer passed as 2nd argument to memory copy function
    memcpy(&p->zText[p->nChar], z, N);
    ^                           ~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29622:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&p->zText[p->nChar-N], z, N);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29622:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&p->zText[p->nChar-N], z, N);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29644:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zText, p->zText, p->nChar+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:29644:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zText, p->zText, p->nChar+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:30809:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(k, 0, sizeof(k));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:30809:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(k, 0, sizeof(k));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:30850:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:30850:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:30857:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:30857:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31030:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p, 0, sizeof(*p));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31030:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p, 0, sizeof(*p));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31036:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(p, 0, sizeof(*p));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31036:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(p, 0, sizeof(*p));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31052:8: warning: variable 'bRc' set but not used [clang-diagnostic-unused-but-set-variable]
  BOOL bRc;
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31064:5: warning: Value stored to 'bRc' is never read [clang-analyzer-deadcode.DeadStores]
    bRc = CloseHandle((HANDLE)p->tid);
    ^     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31064:5: note: Value stored to 'bRc' is never read
    bRc = CloseHandle((HANDLE)p->tid);
    ^     ~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31540:7: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memmove(pMem->z, &pMem->z[2], pMem->n);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31540:7: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
      memmove(pMem->z, &pMem->z[2], pMem->n);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31614:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&m, 0, sizeof(m));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31614:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&m, 0, sizeof(m));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31747:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&y,&x,sizeof(y));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:31747:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&y,&x,sizeof(y));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32310:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(zOut, &zTemp[i+1], sizeof(zTemp)-1-i);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32310:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(zOut, &zTemp[i+1], sizeof(zTemp)-1-i);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32474:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pOut, &u, 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32474:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pOut, &u, 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32515:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pValue, &u, 4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32515:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pValue, &u, 4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32963:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&x,p,4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32963:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&x,p,4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32978:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p,&x,4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32978:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(p,&x,4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32978:3: warning: Null pointer passed as 1st argument to memory copy function [clang-analyzer-unix.cstring.NullArg]
  memcpy(p,&x,4);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 125:'  at line 91691
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91701:10: note: Assuming field 'p3' is 0
  iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;
         ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91701:10: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91702:8: note: Calling 'sqlite3BtreeTransferRow'
  rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74469:11: note: Assuming field 'nPayload' is >= 128
  aOut += putVarint32(aOut, pSrc->info.nPayload);
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:20288:9: note: expanded from macro 'putVarint32'
  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
        ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74469:11: note: '?' condition is false
  aOut += putVarint32(aOut, pSrc->info.nPayload);
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:20288:8: note: expanded from macro 'putVarint32'
  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74470:7: note: Assuming field 'pKeyInfo' is not equal to null
  if( pDest->pKeyInfo==0 ) aOut += putVarint(aOut, iKey);
      ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74470:3: note: Taking false branch
  if( pDest->pKeyInfo==0 ) aOut += putVarint(aOut, iKey);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74473:7: note: Assuming the condition is false
  if( aIn+nIn>pSrc->pPage->aDataEnd ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74473:3: note: Taking false branch
  if( aIn+nIn>pSrc->pPage->aDataEnd ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74477:7: note: Assuming 'nIn' is not equal to 'nRem'
  if( nIn==nRem && nIn<pDest->pPage->maxLocal ){
      ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74477:17: note: Left side of '&&' is false
  if( nIn==nRem && nIn<pDest->pPage->maxLocal ){
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74482:5: note: 'pPgnoOut' initialized to a null pointer value
    u8 *pPgnoOut = 0;
    ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74490:9: note: Assuming 'nOut' is >= field 'nPayload'
    if( nOut<pSrc->info.nPayload ){
        ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74490:5: note: Taking false branch
    if( nOut<pSrc->info.nPayload ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74495:9: note: Assuming 'nRem' is <= 'nIn'
    if( nRem>nIn ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74495:5: note: Taking false branch
    if( nRem>nIn ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74506:13: note: Assuming 'nIn' is > 0
        if( nIn>0 ){
            ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74506:9: note: Taking true branch
        if( nIn>0 ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74507:23: note: Assuming 'nOut' is >= 'nIn'
          int nCopy = MIN(nOut, nIn);
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14476:20: note: expanded from macro 'MIN'
# define MIN(A,B) ((A)<(B)?(A):(B))
                   ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74507:23: note: '?' condition is false
          int nCopy = MIN(nOut, nIn);
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14476:20: note: expanded from macro 'MIN'
# define MIN(A,B) ((A)<(B)?(A):(B))
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74514:13: note: Assuming 'nOut' is <= 0
        if( nOut>0 ){
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74514:9: note: Taking false branch
        if( nOut>0 ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74525:15: note: 'rc' is equal to SQLITE_OK
      }while( rc==SQLITE_OK && nOut>0 );
              ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74525:15: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74504:7: note: Loop condition is false.  Exiting loop
      do{
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74527:11: note: 'rc' is equal to SQLITE_OK
      if( rc==SQLITE_OK && nRem>0 ){
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74527:11: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74527:28: note: Assuming 'nRem' is > 0
      if( rc==SQLITE_OK && nRem>0 ){
                           ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74527:7: note: Taking true branch
      if( rc==SQLITE_OK && nRem>0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74531:18: note: Passing null pointer value via 1st parameter 'p'
        put4byte(pPgnoOut, pgnoNew);
                 ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74531:9: note: Calling 'sqlite3Put4byte'
        put4byte(pPgnoOut, pgnoNew);
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:65141:18: note: expanded from macro 'put4byte'
#define put4byte sqlite3Put4byte
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:32978:3: note: Null pointer passed as 1st argument to memory copy function
  memcpy(p,&x,4);
  ^      ~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:33252:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&a, &x, 8);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:33252:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&a, &x, 8);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:33349:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(z, zName, nName);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:33349:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(z, zName, nName);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:33522:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(new_ht, 0, new_size*sizeof(struct _ht));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:33522:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(new_ht, 0, new_size*sizeof(struct _ht));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:42847:35: warning: unused variable 'sqlite3_os_type' [clang-diagnostic-unused-variable]
static LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;
                                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:43712:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:43712:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:43713:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zDbgBuf, zBuf, nMin);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:43713:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zDbgBuf, zBuf, nMin);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:44888:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&ovlp, 0, sizeof(OVERLAPPED));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:44888:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&ovlp, 0, sizeof(OVERLAPPED));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:44919:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&ovlp, 0, sizeof(OVERLAPPED));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:44919:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&ovlp, 0, sizeof(OVERLAPPED));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45102:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45102:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45108:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45108:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45124:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&overlapped, 0, sizeof(OVERLAPPED));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45124:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&overlapped, 0, sizeof(OVERLAPPED));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45141:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&((char*)pBuf)[nRead], 0, amt-nRead);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45141:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&((char*)pBuf)[nRead], 0, amt-nRead);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45209:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&overlapped, 0, sizeof(OVERLAPPED));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45209:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&overlapped, 0, sizeof(OVERLAPPED));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45702:5: warning: Value stored to 'res' is never read [clang-analyzer-deadcode.DeadStores]
    res = winUnlockReadLock(pFile);
    ^     ~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:45702:5: note: Value stored to 'res' is never read
    res = winUnlockReadLock(pFile);
    ^     ~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46584:14: warning: Access to field 'pShmNode' results in a dereference of a null pointer (loaded from variable 'pShm') [clang-analyzer-core.NullDereference]
  pShmNode = pShm->pShmNode;
             ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46578:7: note: Assuming 'pShm' is null
  if( !pShm ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46578:3: note: Taking true branch
  if( !pShm ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46579:10: note: Calling 'winOpenSharedMemory'
    rc = winOpenSharedMemory(pDbFd);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46290:7: note: 'p' is not equal to null
  if( p==0 ) return SQLITE_IOERR_NOMEM_BKPT;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46290:3: note: Taking false branch
  if( p==0 ) return SQLITE_IOERR_NOMEM_BKPT;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46293:7: note: 'pNew' is not equal to null
  if( pNew==0 ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46293:3: note: Taking false branch
  if( pNew==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46305:3: note: Loop condition is false. Execution continues on line 46311
  for(pShmNode = winShmNodeList; pShmNode; pShmNode=pShmNode->pNext){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46311:7: note: 'pShmNode' is null
  if( pShmNode ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46311:3: note: Taking false branch
  if( pShmNode ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46323:9: note: Assuming field 'bCoreMutex' is 0
    if( sqlite3GlobalConfig.bCoreMutex ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14859:31: note: expanded from macro 'sqlite3GlobalConfig'
  #define sqlite3GlobalConfig sqlite3Config
                              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46323:5: note: Taking false branch
    if( sqlite3GlobalConfig.bCoreMutex ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46331:5: note: Taking true branch
    if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46339:9: note: 'rc' is not equal to SQLITE_OK
    if( rc!=SQLITE_OK ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46339:5: note: Taking true branch
    if( rc!=SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46342:7: note: Control jumps to line 46374
      goto shm_open_err;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46379:3: note: Returning without writing to 'pDbFd->pShm'
  return rc;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46579:10: note: Returning from 'winOpenSharedMemory'
    rc = winOpenSharedMemory(pDbFd);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46580:9: note: Assuming 'rc' is equal to SQLITE_OK
    if( rc!=SQLITE_OK ) return rc;
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46580:5: note: Taking false branch
    if( rc!=SQLITE_OK ) return rc;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46581:5: note: Null pointer value stored to 'pShm'
    pShm = pDbFd->pShm;
    ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46584:14: note: Access to field 'pShmNode' results in a dereference of a null pointer (loaded from variable 'pShm')
  pShmNode = pShm->pShmNode;
             ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46818:7: warning: Value stored to 'rc' is never read [clang-analyzer-deadcode.DeadStores]
      rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46818:7: note: Value stored to 'rc' is never read
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46836:7: warning: Value stored to 'rc' is never read [clang-analyzer-deadcode.DeadStores]
      rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:46836:7: note: Value stored to 'rc' is never read
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:47322:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sAttrData, 0, sizeof(sAttrData));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:47322:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sAttrData, 0, sizeof(sAttrData));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:47425:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pFile, 0, sizeof(winFile));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:47425:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pFile, 0, sizeof(winFile));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:47804:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sAttrData, 0, sizeof(sAttrData));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:47804:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sAttrData, 0, sizeof(sAttrData));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48200:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(zBuf, 0, nBuf);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48200:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(zBuf, 0, nBuf);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48474:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48474:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48780:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(zBuf, 0, iAmt);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48780:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(zBuf, 0, iAmt);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48781:23: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);
                      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48781:23: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);
                      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48785:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(zBuf, p->aData+iOfst, iAmt);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48785:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(zBuf, p->aData+iOfst, iAmt);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48835:23: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);
                      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48835:23: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);
                      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48838:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p->aData+iOfst, z, iAmt);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:48838:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(p->aData+iOfst, z, iAmt);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49031:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pFile, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49031:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pFile, 0, sizeof(*p));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49061:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(p, 0, sizeof(*p));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49061:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(p, 0, sizeof(*p));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49065:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(p->zFName, zName, szName+1);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49065:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(p->zFName, zName, szName+1);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49085:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p, 0, sizeof(*p));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49085:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p, 0, sizeof(*p));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49262:18: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      if( pOut ) memcpy(pOut, pStore->aData, pStore->sz);
                 ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49262:18: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      if( pOut ) memcpy(pOut, pStore->aData, pStore->sz);
                 ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49292:13: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49292:13: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49294:13: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memset(pTo, 0, szPage);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49294:13: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
            memset(pTo, 0, szPage);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49616:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49616:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49617:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(p->u.apSub, 0, sizeof(p->u.apSub));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49617:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(p->u.apSub, 0, sizeof(p->u.apSub));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49656:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49656:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49657:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p->u.aHash, 0, sizeof(p->u.aHash));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:49657:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p->u.aHash, 0, sizeof(p->u.aHash));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50114:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(PCache));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50114:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(PCache));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50282:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50282:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50286:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pPgHdr->pExtra, 0, 8);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50286:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pPgHdr->pExtra, 0, 8);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50477:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(pPage1->pBuf, 0, pCache->szPage);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50477:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(pPage1->pBuf, 0, pCache->szPage);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50545:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(a, 0, sizeof(a));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:50545:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(a, 0, sizeof(a));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:51402:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pcache1, 0, sizeof(pcache1));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:51402:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pcache1, 0, sizeof(pcache1));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:51455:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pcache1, 0, sizeof(pcache1));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:51455:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pcache1, 0, sizeof(pcache1));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:52259:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(aBucket, 0, sizeof(aBucket));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:52259:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(aBucket, 0, sizeof(aBucket));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:54130:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:54130:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:54133:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(zHeader, 0, sizeof(aJournalMagic)+4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:54133:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(zHeader, 0, sizeof(aJournalMagic)+4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:54152:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&zHeader[sizeof(aJournalMagic)+20], 0,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:54152:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&zHeader[sizeof(aJournalMagic)+20], 0,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55066:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pData, (u8*)aData, pPager->pageSize);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55066:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pData, (u8*)aData, pPager->pageSize);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55077:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55077:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55264:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(pTmp, 0, szPage);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55264:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(pTmp, 0, szPage);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55575:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&zSuper[-4], 0, 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55575:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&zSuper[-4], 0, 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55645:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55645:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55648:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55648:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:56371:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(pNew+pageSize, 0, 8);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:56371:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(pNew+pageSize, 0, 8);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:56470:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pDest, 0, N);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:56470:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pDest, 0, N);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:56648:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p->pExtra, 0, 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:56648:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p->pExtra, 0, 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:56893:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:56893:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57050:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57050:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57325:7: warning: variable 'nUri' set but not used [clang-diagnostic-unused-but-set-variable]
  int nUri = 0;            /* Number of URI parameters */
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57462:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pPtr, &pPager, sizeof(pPager));  pPtr += sizeof(pPager);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57462:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pPtr, &pPager, sizeof(pPager));  pPtr += sizeof(pPager);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57468:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname + 1;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57468:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname + 1;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57470:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pPtr, zUri, nUriByte);       pPtr += nUriByte;
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57470:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pPtr, zUri, nUriByte);       pPtr += nUriByte;
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57480:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57480:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57481:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pPtr, "-journal",8);           pPtr += 8 + 1;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57481:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pPtr, "-journal",8);           pPtr += 8 + 1;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57494:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57494:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57495:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pPtr, "-wal", 4);              pPtr += 4 + 1;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57495:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pPtr, "-wal", 4);              pPtr += 4 + 1;
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57495:43: warning: Value stored to 'pPtr' is never read [clang-analyzer-deadcode.DeadStores]
    memcpy(pPtr, "-wal", 4);              pPtr += 4 + 1;
                                          ^       ~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57495:43: note: Value stored to 'pPtr' is never read
    memcpy(pPtr, "-wal", 4);              pPtr += 4 + 1;
                                          ^       ~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57990:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(dbFileVers, 0, sizeof(dbFileVers));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57990:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(dbFileVers, 0, sizeof(dbFileVers));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:58186:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(pPg->pData, 0, pPager->pageSize);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:58186:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(pPg->pData, 0, pPager->pageSize);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:58933:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:58933:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:59486:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:59486:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:60180:13: warning: Dereference of null pointer (loaded from variable 'pbOpen') [clang-analyzer-core.NullDereference]
    *pbOpen = 1;
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57841:8: note: Assuming field 'pWal' is equal to null
  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:53472:26: note: expanded from macro 'pagerUseWal'
# define pagerUseWal(x) ((x)->pWal!=0)
                         ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57841:7: note: Left side of '&&' is true
  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57841:31: note: Assuming field 'eState' is equal to PAGER_OPEN
  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57841:3: note: Taking true branch
  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57848:9: note: Assuming 'rc' is equal to SQLITE_OK
    if( rc!=SQLITE_OK ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57848:5: note: Taking false branch
    if( rc!=SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57856:9: note: Assuming field 'eLock' is <= SHARED_LOCK
    if( pPager->eLock<=SHARED_LOCK ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57856:5: note: Taking true branch
    if( pPager->eLock<=SHARED_LOCK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57857:12: note: Calling 'hasHotJournal'
      rc = hasHotJournal(pPager, &bHotJournal);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57713:20: note: Assuming field 'pMethods' is equal to null
  int jrnlOpen = !!isOpen(pPager->jfd);
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:53445:22: note: expanded from macro 'isOpen'
#define isOpen(pFd) ((pFd)->pMethods!=0)
                     ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57724:8: note: 'jrnlOpen' is 0
  if( !jrnlOpen ){
       ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57724:3: note: Taking true branch
  if( !jrnlOpen ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57727:7: note: Assuming 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK && exists ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57727:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57727:24: note: Assuming 'exists' is 0
  if( rc==SQLITE_OK && exists ){
                       ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57727:3: note: Taking false branch
  if( rc==SQLITE_OK && exists ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57799:3: note: Returning without writing to 'pPager->tempFile', which participates in a condition later
  return rc;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57799:3: note: Returning without writing to 'pPager->pWal', which participates in a condition later
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57857:12: note: Returning from 'hasHotJournal'
      rc = hasHotJournal(pPager, &bHotJournal);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57859:9: note: 'rc' is equal to SQLITE_OK
    if( rc!=SQLITE_OK ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57859:5: note: Taking false branch
    if( rc!=SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57862:9: note: 'bHotJournal' is 0
    if( bHotJournal ){
        ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57862:5: note: Taking false branch
    if( bHotJournal ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57965:9: note: Assuming field 'tempFile' is 0
    if( !pPager->tempFile && pPager->hasHeldSharedLock ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57965:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57965:30: note: Assuming field 'hasHeldSharedLock' is 0
    if( !pPager->tempFile && pPager->hasHeldSharedLock ){
                             ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:57965:5: note: Taking false branch
    if( !pPager->tempFile && pPager->hasHeldSharedLock ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:58011:10: note: Calling 'pagerOpenWalIfPresent'
    rc = pagerOpenWalIfPresent(pPager);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55927:16: note: Field 'tempFile' is 0
  if( !pPager->tempFile ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55927:3: note: Taking true branch
  if( !pPager->tempFile ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55932:9: note: Assuming 'rc' is equal to SQLITE_OK
    if( rc==SQLITE_OK ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55932:5: note: Taking true branch
    if( rc==SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55933:11: note: Assuming 'isWal' is not equal to 0
      if( isWal ){
          ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55933:7: note: Taking true branch
      if( isWal ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55936:14: note: Calling 'pagerPagecount'
        rc = pagerPagecount(pPager, &nPage);
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55875:11: note: Calling 'sqlite3WalDbsize'
  nPage = sqlite3WalDbsize(pPager->pWal);
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:63509:7: note: Assuming 'pWal' is non-null
  if( pWal && ALWAYS(pWal->readLock>=0) ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:63509:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:63509:22: note: Assuming field 'readLock' is >= 0
  if( pWal && ALWAYS(pWal->readLock>=0) ){
                     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13946:26: note: expanded from macro 'ALWAYS'
# define ALWAYS(X)      (X)
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:63509:3: note: Taking true branch
  if( pWal && ALWAYS(pWal->readLock>=0) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55875:11: note: Returning from 'sqlite3WalDbsize'
  nPage = sqlite3WalDbsize(pPager->pWal);
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55882:7: note: Assuming 'nPage' is not equal to 0
  if( nPage==0 && ALWAYS(isOpen(pPager->fd)) ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55882:16: note: Left side of '&&' is false
  if( nPage==0 && ALWAYS(isOpen(pPager->fd)) ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55895:7: note: Assuming 'nPage' is <= field 'mxPgno'
  if( nPage>pPager->mxPgno ){
      ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55895:3: note: Taking false branch
  if( nPage>pPager->mxPgno ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55900:3: note: Returning without writing to 'pPager->tempFile', which participates in a condition later
  return SQLITE_OK;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55900:3: note: Returning without writing to 'pPager->pWal', which participates in a condition later
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55936:14: note: Returning from 'pagerPagecount'
        rc = pagerPagecount(pPager, &nPage);
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55937:13: note: 'rc' is 0
        if( rc ) return rc;
            ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55937:9: note: Taking false branch
        if( rc ) return rc;
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55938:13: note: 'nPage' is not equal to 0
        if( nPage==0 ){
            ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55938:9: note: Taking false branch
        if( nPage==0 ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55942:44: note: Passing null pointer value via 2nd parameter 'pbOpen'
          rc = sqlite3PagerOpenWal(pPager, 0);
                                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:55942:16: note: Calling 'sqlite3PagerOpenWal'
          rc = sqlite3PagerOpenWal(pPager, 0);
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:60168:16: note: Field 'tempFile' is 0
  if( !pPager->tempFile && !pPager->pWal ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:60168:7: note: Left side of '&&' is true
  if( !pPager->tempFile && !pPager->pWal ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:60168:37: note: Field 'pWal' is non-null
  if( !pPager->tempFile && !pPager->pWal ){
                                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:60168:3: note: Taking false branch
  if( !pPager->tempFile && !pPager->pWal ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:60180:13: note: Dereference of null pointer (loaded from variable 'pbOpen')
    *pbOpen = 1;
     ~~~~~~ ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:60931:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset((void*)&apNew[pWal->nWiData], 0,
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:60931:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset((void*)&apNew[pWal->nWiData], 0,
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61086:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61086:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61088:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61088:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61117:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&aFrame[8], pWal->hdr.aSalt, 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61117:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&aFrame[8], pWal->hdr.aSalt, 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61126:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&aFrame[8], 0, 16);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61126:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&aFrame[8], 0, 16);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61389:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset((void *)&sLoc.aPgno[iLimit+1], 0, nByte);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61389:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset((void *)&sLoc.aPgno[iLimit+1], 0, nByte);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61436:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset((void*)&sLoc.aPgno[1], 0, nByte);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61436:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset((void*)&sLoc.aPgno[1], 0, nByte);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61527:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61527:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61570:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61570:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61648:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&aShare[nHdr32], &aPrivate[nHdr32], WALINDEX_PGSZ-nHdr);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61648:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&aShare[nHdr32], &aPrivate[nHdr32], WALINDEX_PGSZ-nHdr);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61931:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61931:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61969:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(aSub, 0, sizeof(aSub));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:61969:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(aSub, 0, sizeof(aSub));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62055:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, nByte);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62055:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, nByte);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62247:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&pWal->hdr.aSalt[1], &salt1, 4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62247:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&pWal->hdr.aSalt[1], &salt1, 4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62596:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&h1, (void *)&aHdr[0], sizeof(h1)); /* Possible TSAN false-positive */
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62596:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&h1, (void *)&aHdr[0], sizeof(h1)); /* Possible TSAN false-positive */
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62598:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62598:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62613:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62613:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62823:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:62823:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:63608:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:63608:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:63912:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:63912:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:64192:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:64192:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66140:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(((u8*)pKey)+pCur->nKey, 0, 9+8);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66140:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(((u8*)pKey)+pCur->nKey, 0, 9+8);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66943:11: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memmove(&data[iFree+sz+sz2], &data[iFree+sz], iFree2-(iFree+sz));
          ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66943:11: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
          memmove(&data[iFree+sz+sz2], &data[iFree+sz], iFree2-(iFree+sz));
          ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66951:9: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memmove(&data[cbrk], &data[top], iFree-top);
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66951:9: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
        memmove(&data[cbrk], &data[top], iFree-top);
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66990:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&temp[iCellStart], &data[iCellStart], usableSize - iCellStart);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66990:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&temp[iCellStart], &data[iCellStart], usableSize - iCellStart);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66993:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&data[cbrk], &src[pc], size);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:66993:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&data[cbrk], &src[pc], size);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67006:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&data[iCellFirst], 0, cbrk-iCellFirst);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67006:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&data[iCellFirst], 0, cbrk-iCellFirst);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67050:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&aData[iAddr], &aData[pc], 2);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67050:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&aData[iAddr], &aData[pc], 2);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67276:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&data[iStart], 0, iSize);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67276:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&data[iStart], 0, iSize);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67537:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&data[hdr], 0, pBt->usableSize - hdr);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67537:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&data[hdr], 0, pBt->usableSize - hdr);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67541:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&data[hdr+1], 0, 4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67541:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&data[hdr+1], 0, 4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67888:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(zFullPathname, zFilename, nFilename);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:67888:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(zFullPathname, zFilename, nFilename);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:68170:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(pBt->pTmpSpace, 0, 8);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:68170:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(pBt->pTmpSpace, 0, 8);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:68564:11: warning: Although the value stored to 'nPageHeader' is used in the enclosing expression, the value is never actually read from 'nPageHeader' [clang-analyzer-deadcode.DeadStores]
  nPage = nPageHeader = get4byte(28+(u8*)pPage1->aData);
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:68564:11: note: Although the value stored to 'nPageHeader' is used in the enclosing expression, the value is never actually read from 'nPageHeader'
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:68785:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(data, zMagicHeader, sizeof(zMagicHeader));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:68785:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(data, zMagicHeader, sizeof(zMagicHeader));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:68796:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&data[24], 0, 100-24);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:68796:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&data[24], 0, 100-24);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:69971:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, offsetof(BtCursor, BTCURSOR_FIRST_UNINIT));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:69971:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, offsetof(BtCursor, BTCURSOR_FIRST_UNINIT));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:70238:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pPayload, pBuf, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:70238:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pPayload, pBuf, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:70241:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pBuf, pPayload, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:70241:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pBuf, pPayload, nByte);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:70353:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:70353:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:70949:11: warning: Value stored to 'rc' is never read [clang-analyzer-deadcode.DeadStores]
          rc = SQLITE_OK;
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:70949:11: note: Value stored to 'rc' is never read
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71098:11: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memset(((u8*)pCellKey)+nCell,0,nOverrun); /* Fix uninit warnings */
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71098:11: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
          memset(((u8*)pCellKey)+nCell,0,nOverrun); /* Fix uninit warnings */
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71514:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71514:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71538:13: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71538:13: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
            memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71544:13: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71544:13: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
            memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71567:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71567:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71569:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71569:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71634:13: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memcpy(&aData[8+closest*4], &aData[4+k*4], 4);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71634:13: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
            memcpy(&aData[8+closest*4], &aData[4+k*4], 4);
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71770:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pPage->aData, 0, pPage->pBt->pageSize);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71770:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pPage->aData, 0, pPage->pBt->pageSize);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71998:26: warning: The left operand of '+' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
    nPayload = pX->nData + pX->nZero;
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 134:'  at line 92352
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92363:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
      ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92363:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92366:8: note: Assuming the condition is false
  rc = ExpandBlob(pIn2);
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:21784:27: note: expanded from macro 'ExpandBlob'
  #define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)
                          ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92366:8: note: '?' condition is false
  rc = ExpandBlob(pIn2);
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:21784:26: note: expanded from macro 'ExpandBlob'
  #define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92367:7: note: 'rc' is 0
  if( rc ) goto abort_due_to_error;
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92367:3: note: Taking false branch
  if( rc ) goto abort_due_to_error;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92374:9: note: Assuming the condition is false
      ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92374:8: note: '?' condition is false
      ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92372:8: note: Calling 'sqlite3BtreeInsert'
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:7: note: Assuming field 'eState' is not equal to CURSOR_FAULT
  if( pCur->eState==CURSOR_FAULT ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:3: note: Taking false branch
  if( pCur->eState==CURSOR_FAULT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:7: note: Assuming the condition is false
  if( pCur->curFlags & BTCF_Multiple ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:3: note: Taking false branch
  if( pCur->curFlags & BTCF_Multiple ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:7: note: Assuming field 'pKeyInfo' is not equal to null
  if( pCur->pKeyInfo==0 ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:3: note: Taking false branch
  if( pCur->pKeyInfo==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: 'loc' is equal to 0
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:19: note: Assuming the condition is false
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:5: note: Taking false branch
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74291:9: note: 'loc' is equal to 0
    if( loc==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74291:5: note: Taking true branch
    if( loc==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74293:11: note: Assuming 'pCur->info.nKey' is not equal to 'pX->nKey'
      if( pCur->info.nKey==pX->nKey ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74293:7: note: Taking false branch
      if( pCur->info.nKey==pX->nKey ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74309:7: note: Assuming field 'nFree' is >= 0
  if( pPage->nFree<0 ){
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74309:3: note: Taking false branch
  if( pPage->nFree<0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74324:7: note: Assuming the condition is false
  if( flags & BTREE_PREFORMAT ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74324:3: note: Taking false branch
  if( flags & BTREE_PREFORMAT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74337:10: note: Calling 'fillInCell'
    rc = fillInCell(pPage, newCell, pX, &szNew);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71997:7: note: Assuming field 'intKey' is not equal to 0
  if( pPage->intKey ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71997:3: note: Taking true branch
  if( pPage->intKey ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71998:26: note: The left operand of '+' is a garbage value
    nPayload = pX->nData + pX->nZero;
               ~~~~~~~~~ ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72023:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pPayload, pSrc, nSrc);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72023:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pPayload, pSrc, nSrc);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72023:5: warning: Null pointer passed as 2nd argument to memory copy function [clang-analyzer-unix.cstring.NullArg]
    memcpy(pPayload, pSrc, nSrc);
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 124:'  at line 91597
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91625:7: note: Assuming the condition is false
  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
      ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91625:29: note: Left side of '&&' is false
  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91649:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
      ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91649:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91650:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91650:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91654:18: note: Assuming the condition is false
  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91654:17: note: '?' condition is false
  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91655:7: note: Assuming the condition is false
  if( pData->flags & MEM_Zero ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91655:3: note: Taking false branch
  if( pData->flags & MEM_Zero ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91660:3: note: Null pointer value stored to 'x.pKey'
  x.pKey = 0;
  ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91661:8: note: Calling 'sqlite3BtreeInsert'
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:7: note: Assuming field 'eState' is not equal to CURSOR_FAULT
  if( pCur->eState==CURSOR_FAULT ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:3: note: Taking false branch
  if( pCur->eState==CURSOR_FAULT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:7: note: Assuming the condition is false
  if( pCur->curFlags & BTCF_Multiple ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:3: note: Taking false branch
  if( pCur->curFlags & BTCF_Multiple ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:7: note: Assuming field 'pKeyInfo' is not equal to null
  if( pCur->pKeyInfo==0 ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:3: note: Taking false branch
  if( pCur->pKeyInfo==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: 'loc' is equal to 0
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:19: note: Assuming the condition is false
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:5: note: Taking false branch
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74291:9: note: 'loc' is equal to 0
    if( loc==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74291:5: note: Taking true branch
    if( loc==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74293:11: note: Assuming 'pCur->info.nKey' is not equal to 'pX->nKey'
      if( pCur->info.nKey==pX->nKey ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74293:7: note: Taking false branch
      if( pCur->info.nKey==pX->nKey ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74309:7: note: Assuming field 'nFree' is >= 0
  if( pPage->nFree<0 ){
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74309:3: note: Taking false branch
  if( pPage->nFree<0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74324:7: note: Assuming the condition is false
  if( flags & BTREE_PREFORMAT ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74324:3: note: Taking false branch
  if( flags & BTREE_PREFORMAT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74337:10: note: Calling 'fillInCell'
    rc = fillInCell(pPage, newCell, pX, &szNew);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71997:7: note: Assuming field 'intKey' is 0
  if( pPage->intKey ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71997:3: note: Taking false branch
  if( pPage->intKey ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72007:5: note: Null pointer value stored to 'pSrc'
    pSrc = pX->pKey;
    ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72008:16: note: Assuming 'nPayload' is >= 128
    nHeader += putVarint32(&pCell[nHeader], nPayload);
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:20288:9: note: expanded from macro 'putVarint32'
  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
        ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72008:16: note: '?' condition is false
    nHeader += putVarint32(&pCell[nHeader], nPayload);
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:20288:8: note: expanded from macro 'putVarint32'
  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72013:7: note: Assuming 'nPayload' is <= field 'maxLocal'
  if( nPayload<=pPage->maxLocal ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72013:3: note: Taking true branch
  if( nPayload<=pPage->maxLocal ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72019:9: note: Assuming 'n' is >= 4
    if( n<4 ) n = 4;
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72019:5: note: Taking false branch
    if( n<4 ) n = 4;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72023:5: note: Null pointer passed as 2nd argument to memory copy function
    memcpy(pPayload, pSrc, nSrc);
    ^                ~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72024:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pPayload+nSrc, 0, nPayload-nSrc);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72024:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pPayload+nSrc, 0, nPayload-nSrc);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72081:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pPayload, pSrc, n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72081:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pPayload, pSrc, n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72081:7: warning: Null pointer passed as 2nd argument to memory copy function [clang-analyzer-unix.cstring.NullArg]
      memcpy(pPayload, pSrc, n);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 124:'  at line 91597
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91625:7: note: Assuming the condition is false
  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
      ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91625:29: note: Left side of '&&' is false
  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91649:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
      ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91649:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91650:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91650:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91654:18: note: Assuming the condition is false
  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91654:17: note: '?' condition is false
  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91655:7: note: Assuming the condition is false
  if( pData->flags & MEM_Zero ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91655:3: note: Taking false branch
  if( pData->flags & MEM_Zero ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91660:3: note: Null pointer value stored to 'x.pKey'
  x.pKey = 0;
  ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91661:8: note: Calling 'sqlite3BtreeInsert'
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:7: note: Assuming field 'eState' is not equal to CURSOR_FAULT
  if( pCur->eState==CURSOR_FAULT ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:3: note: Taking false branch
  if( pCur->eState==CURSOR_FAULT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:7: note: Assuming the condition is false
  if( pCur->curFlags & BTCF_Multiple ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:3: note: Taking false branch
  if( pCur->curFlags & BTCF_Multiple ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:7: note: Assuming field 'pKeyInfo' is not equal to null
  if( pCur->pKeyInfo==0 ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:3: note: Taking false branch
  if( pCur->pKeyInfo==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: 'loc' is equal to 0
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:19: note: Assuming the condition is false
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:5: note: Taking false branch
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74291:9: note: 'loc' is equal to 0
    if( loc==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74291:5: note: Taking true branch
    if( loc==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74293:11: note: Assuming 'pCur->info.nKey' is not equal to 'pX->nKey'
      if( pCur->info.nKey==pX->nKey ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74293:7: note: Taking false branch
      if( pCur->info.nKey==pX->nKey ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74309:7: note: Assuming field 'nFree' is >= 0
  if( pPage->nFree<0 ){
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74309:3: note: Taking false branch
  if( pPage->nFree<0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74324:7: note: Assuming the condition is false
  if( flags & BTREE_PREFORMAT ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74324:3: note: Taking false branch
  if( flags & BTREE_PREFORMAT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74337:10: note: Calling 'fillInCell'
    rc = fillInCell(pPage, newCell, pX, &szNew);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71997:7: note: Assuming field 'intKey' is 0
  if( pPage->intKey ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:71997:3: note: Taking false branch
  if( pPage->intKey ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72007:5: note: Null pointer value stored to 'pSrc'
    pSrc = pX->pKey;
    ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72008:16: note: Assuming 'nPayload' is >= 128
    nHeader += putVarint32(&pCell[nHeader], nPayload);
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:20288:9: note: expanded from macro 'putVarint32'
  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
        ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72008:16: note: '?' condition is false
    nHeader += putVarint32(&pCell[nHeader], nPayload);
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:20288:8: note: expanded from macro 'putVarint32'
  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72013:7: note: Assuming 'nPayload' is > field 'maxLocal'
  if( nPayload<=pPage->maxLocal ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72013:3: note: Taking false branch
  if( nPayload<=pPage->maxLocal ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72035:7: note: Assuming 'n' is <= field 'maxLocal'
  if( n > pPage->maxLocal ) n = mn;
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72035:3: note: Taking false branch
  if( n > pPage->maxLocal ) n = mn;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72067:3: note: Loop condition is true.  Entering loop body
  while( 1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72069:9: note: Assuming 'n' is <= 'spaceLeft'
    if( n>spaceLeft ) n = spaceLeft;
        ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72069:5: note: Taking false branch
    if( n>spaceLeft ) n = spaceLeft;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72080:9: note: 'nSrc' is >= 'n'
    if( nSrc>=n ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72080:5: note: Taking true branch
    if( nSrc>=n ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72081:7: note: Null pointer passed as 2nd argument to memory copy function
      memcpy(pPayload, pSrc, n);
      ^                ~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72084:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pPayload, pSrc, n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72084:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pPayload, pSrc, n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72086:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(pPayload, 0, n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72086:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(pPayload, 0, n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72191:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&data[hdr+1], 0, 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72191:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&data[hdr+1], 0, 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72197:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(ptr, ptr+2, 2*(pPage->nCell - idx));
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72197:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
    memmove(ptr, ptr+2, 2*(pPage->nCell - idx));
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72242:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pTemp, pCell, sz);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72242:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pTemp, pCell, sz);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72286:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&data[idx+4], pCell+4, sz-4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72286:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&data[idx+4], pCell+4, sz-4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72289:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&data[idx], pCell, sz);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72289:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&data[idx], pCell, sz);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72292:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(pIns+2, pIns, 2*(pPage->nCell - i));
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72292:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
    memmove(pIns+2, pIns, 2*(pPage->nCell - i));
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72471:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&pTmp[j], &aData[j], usableSize - j);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72471:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&pTmp[j], &aData[j], usableSize - j);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72473:28: warning: The left operand of '<=' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73079:7: note: Assuming 'aOvflSpace' is non-null
  if( !aOvflSpace ){
      ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73079:3: note: Taking false branch
  if( !aOvflSpace ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73096:7: note: Assuming 'i' is >= 2
  if( i<2 ){
      ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73096:3: note: Taking false branch
  if( i<2 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73100:9: note: Assuming 'iParentIdx' is not equal to 0
    if( iParentIdx==0 ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73100:5: note: Taking false branch
    if( iParentIdx==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73102:15: note: Assuming 'iParentIdx' is not equal to 'i'
    }else if( iParentIdx==i ){
              ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73102:11: note: Taking false branch
    }else if( iParentIdx==i ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73110:7: note: Assuming the condition is false
  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73110:3: note: Taking false branch
  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73116:3: note: Loop condition is true.  Entering loop body
  while( 1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73117:9: note: 'rc' is equal to SQLITE_OK
    if( rc==SQLITE_OK ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73117:5: note: Taking true branch
    if( rc==SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73120:9: note: 'rc' is 0
    if( rc ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73120:5: note: Taking false branch
    if( rc ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73124:9: note: Assuming field 'nFree' is >= 0
    if( apOld[i]->nFree<0 ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73124:5: note: Taking false branch
    if( apOld[i]->nFree<0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73131:9: note: Assuming the condition is true
    if( (i--)==0 ) break;
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73131:5: note: Taking true branch
    if( (i--)==0 ) break;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73131:20: note:  Execution continues on line 73172
    if( (i--)==0 ) break;
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73185:7: note: Assuming field 'apCell' is not equal to null
  if( b.apCell==0 ){
      ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73185:3: note: Taking false branch
  if( b.apCell==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73212:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<nOld; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73224:9: note: Assuming the condition is false
    if( pOld->aData[0]!=apOld[0]->aData[0] ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73224:5: note: Taking false branch
    if( pOld->aData[0]!=apOld[0]->aData[0] ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73247:9: note: Assuming field 'nOverflow' is <= 0
    if( pOld->nOverflow>0 ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73247:5: note: Taking false branch
    if( pOld->nOverflow>0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73265:12: note: Assuming 'piCell' is >= 'piEnd'
    while( piCell<piEnd ){
           ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73265:5: note: Loop condition is false. Execution continues on line 73271
    while( piCell<piEnd ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73274:18: note: Left side of '&&' is false
    if( i<nOld-1 && !leafData){
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73212:3: note: Loop condition is false. Execution continues on line 73324
  for(i=0; i<nOld; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73325:3: note: Loop condition is true.  Entering loop body
  for(i=k=0; i<nOld; i++, k++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73329:9: note: 'k' is 0
    if( k && b.ixNx[k]==b.ixNx[k-1] ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73329:11: note: Left side of '&&' is false
    if( k && b.ixNx[k]==b.ixNx[k-1] ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73332:9: note: Assuming 'leafData' is not equal to 0
    if( !leafData ){
        ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73332:5: note: Taking false branch
    if( !leafData ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73339:14: note: Assuming 'j' is >= field 'nOverflow'
    for(j=0; j<p->nOverflow; j++){
             ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73339:5: note: Loop condition is false. Execution continues on line 73342
    for(j=0; j<p->nOverflow; j++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73325:3: note: Loop condition is false. Execution continues on line 73344
  for(i=k=0; i<nOld; i++, k++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73345:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<k; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73347:12: note: Assuming the condition is false
    while( szNew[i]>usableSpace ){
           ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73347:5: note: Loop condition is false. Execution continues on line 73366
    while( szNew[i]>usableSpace ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73366:5: note: Loop condition is false. Execution continues on line 73380
    while( cntNew[i]<b.nCell ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73380:5: note: Taking true branch
    if( cntNew[i]>=b.nCell ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73345:3: note: Loop condition is false. Execution continues on line 73399
  for(i=0; i<k; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73399:3: note: Loop condition is false. Execution continues on line 73437
  for(i=k-1; i>0; i--){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73448:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<k; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73450:9: note: 'i' is < 'nOld'
    if( i<nOld ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73450:5: note: Taking true branch
    if( i<nOld ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73455:55: note: Assuming the condition is false
      if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv)) ){
                                                      ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73455:11: note: Assuming the condition is false
      if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv)) ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73455:7: note: Taking false branch
      if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv)) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73458:11: note: Assuming 'rc' is 0
      if( rc ) goto balance_cleanup;
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73458:7: note: Taking false branch
      if( rc ) goto balance_cleanup;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73448:3: note: Loop condition is false. Execution continues on line 73490
  for(i=0; i<k; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73490:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73493:5: note: Loop condition is false. Execution continues on line 73490
    for(j=0; j<i; j++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73490:3: note: Loop condition is false. Execution continues on line 73507
  for(i=0; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73507:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73509:5: note: Loop condition is false. Execution continues on line 73512
    for(j=1; j<nNew; j++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73514:9: note: 'iBest' is equal to 'i'
    if( iBest!=i ){
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73514:5: note: Taking false branch
    if( iBest!=i ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73507:3: note: Loop condition is false. Execution continues on line 73536
  for(i=0; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73544:7: note: Assuming the condition is false
  if( (pageFlags & PTF_LEAF)==0 && nOld!=nNew ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73544:33: note: Left side of '&&' is false
  if( (pageFlags & PTF_LEAF)==0 && nOld!=nNew ){
                                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73565:7: note: Assuming field 'autoVacuum' is 0
  if( ISAUTOVACUUM ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:65102:22: note: expanded from macro 'ISAUTOVACUUM'
#define ISAUTOVACUUM (pBt->autoVacuum)
                     ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73565:3: note: Taking false branch
  if( ISAUTOVACUUM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73608:3: note: Loop condition is false. Execution continues on line 73689
  for(i=0; i<nNew-1; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73689:3: note: Loop condition is true.  Entering loop body
  for(i=1-nNew; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73690:15: note: 'i' is >= 0
    int iPg = i<0 ? -i : i;
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73690:15: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73692:5: note: Taking false branch
    if( abDone[iPg] ) continue;         /* Skip pages already processed */
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73693:9: note: 'i' is >= 0
    if( i>=0                            /* On the upwards pass, or... */
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73694:6: note: Left side of '||' is true
     || cntOld[iPg-1]>=cntNew[iPg-1]    /* Condition (1) is true */
     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73708:11: note: 'iPg' is equal to 0
      if( iPg==0 ){
          ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73708:7: note: Taking true branch
      if( iPg==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73717:12: note: Calling 'editPage'
      rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72687:7: note: 'iOld' is >= 'iNew'
  if( iOld<iNew ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72687:3: note: Taking false branch
  if( iOld<iNew ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72693:7: note: Assuming 'iNewEnd' is >= 'iOldEnd'
  if( iNewEnd < iOldEnd ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72693:3: note: Taking false branch
  if( iNewEnd < iOldEnd ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72700:7: note: Assuming 'pData' is < 'pBegin'
  if( pData<pBegin ) goto editpage_fail;
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72700:3: note: Taking true branch
  if( pData<pBegin ) goto editpage_fail;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72700:22: note: Control jumps to line 72762
  if( pData<pBegin ) goto editpage_fail;
                     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72762:3: note: Calling 'populateCellCache'
  populateCellCache(pCArray, iNew, nNew);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72408:3: note: Loop condition is false. Execution continues on line 72408
  while( N>0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72762:3: note: Returning from 'populateCellCache'
  populateCellCache(pCArray, iNew, nNew);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72763:10: note: Calling 'rebuildPage'
  return rebuildPage(pCArray, iNew, nNew, pPg);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72470:13: note: Assuming 'j' is <= 'usableSize'
  if( NEVER(j>(u32)usableSize) ){ j = 0; }
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13947:26: note: expanded from macro 'NEVER'
# define NEVER(X)       (X)
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72470:3: note: Taking false branch
  if( NEVER(j>(u32)usableSize) ){ j = 0; }
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72473:12: note: Left side of '&&' is true
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72473:3: note: Loop condition is true.  Entering loop body
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72473:51: note: The value 1 is assigned to 'k'
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
                                                  ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72473:28: note: The left operand of '<=' is a garbage value
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
           ~~~~~~~~~~~~~~~~^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72494:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(pData, pCell, sz);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72494:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
    memmove(pData, pCell, sz);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72556:28: warning: The left operand of '<=' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73079:7: note: Assuming 'aOvflSpace' is non-null
  if( !aOvflSpace ){
      ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73079:3: note: Taking false branch
  if( !aOvflSpace ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73096:7: note: Assuming 'i' is >= 2
  if( i<2 ){
      ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73096:3: note: Taking false branch
  if( i<2 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73100:9: note: Assuming 'iParentIdx' is not equal to 0
    if( iParentIdx==0 ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73100:5: note: Taking false branch
    if( iParentIdx==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73102:15: note: Assuming 'iParentIdx' is not equal to 'i'
    }else if( iParentIdx==i ){
              ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73102:11: note: Taking false branch
    }else if( iParentIdx==i ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73110:7: note: Assuming the condition is false
  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73110:3: note: Taking false branch
  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73116:3: note: Loop condition is true.  Entering loop body
  while( 1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73117:9: note: 'rc' is equal to SQLITE_OK
    if( rc==SQLITE_OK ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73117:5: note: Taking true branch
    if( rc==SQLITE_OK ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73120:9: note: 'rc' is 0
    if( rc ){
        ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73120:5: note: Taking false branch
    if( rc ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73124:9: note: Assuming field 'nFree' is >= 0
    if( apOld[i]->nFree<0 ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73124:5: note: Taking false branch
    if( apOld[i]->nFree<0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73131:9: note: Assuming the condition is true
    if( (i--)==0 ) break;
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73131:5: note: Taking true branch
    if( (i--)==0 ) break;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73131:20: note:  Execution continues on line 73172
    if( (i--)==0 ) break;
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73185:7: note: Assuming field 'apCell' is not equal to null
  if( b.apCell==0 ){
      ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73185:3: note: Taking false branch
  if( b.apCell==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73212:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<nOld; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73224:9: note: Assuming the condition is false
    if( pOld->aData[0]!=apOld[0]->aData[0] ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73224:5: note: Taking false branch
    if( pOld->aData[0]!=apOld[0]->aData[0] ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73247:9: note: Assuming field 'nOverflow' is <= 0
    if( pOld->nOverflow>0 ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73247:5: note: Taking false branch
    if( pOld->nOverflow>0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73265:12: note: Assuming 'piCell' is >= 'piEnd'
    while( piCell<piEnd ){
           ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73265:5: note: Loop condition is false. Execution continues on line 73271
    while( piCell<piEnd ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73274:18: note: Left side of '&&' is false
    if( i<nOld-1 && !leafData){
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73212:3: note: Loop condition is false. Execution continues on line 73324
  for(i=0; i<nOld; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73325:3: note: Loop condition is true.  Entering loop body
  for(i=k=0; i<nOld; i++, k++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73329:9: note: 'k' is 0
    if( k && b.ixNx[k]==b.ixNx[k-1] ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73329:11: note: Left side of '&&' is false
    if( k && b.ixNx[k]==b.ixNx[k-1] ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73332:9: note: Assuming 'leafData' is not equal to 0
    if( !leafData ){
        ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73332:5: note: Taking false branch
    if( !leafData ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73339:14: note: Assuming 'j' is >= field 'nOverflow'
    for(j=0; j<p->nOverflow; j++){
             ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73339:5: note: Loop condition is false. Execution continues on line 73342
    for(j=0; j<p->nOverflow; j++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73325:3: note: Loop condition is false. Execution continues on line 73344
  for(i=k=0; i<nOld; i++, k++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73345:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<k; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73347:12: note: Assuming the condition is false
    while( szNew[i]>usableSpace ){
           ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73347:5: note: Loop condition is false. Execution continues on line 73366
    while( szNew[i]>usableSpace ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73366:5: note: Loop condition is false. Execution continues on line 73380
    while( cntNew[i]<b.nCell ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73380:5: note: Taking true branch
    if( cntNew[i]>=b.nCell ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73345:3: note: Loop condition is false. Execution continues on line 73399
  for(i=0; i<k; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73399:3: note: Loop condition is false. Execution continues on line 73437
  for(i=k-1; i>0; i--){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73448:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<k; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73450:9: note: 'i' is < 'nOld'
    if( i<nOld ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73450:5: note: Taking true branch
    if( i<nOld ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73455:55: note: Assuming the condition is false
      if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv)) ){
                                                      ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73455:11: note: Assuming the condition is false
      if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv)) ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73455:7: note: Taking false branch
      if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv)) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73458:11: note: Assuming 'rc' is 0
      if( rc ) goto balance_cleanup;
          ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73458:7: note: Taking false branch
      if( rc ) goto balance_cleanup;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73448:3: note: Loop condition is false. Execution continues on line 73490
  for(i=0; i<k; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73490:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73493:5: note: Loop condition is false. Execution continues on line 73490
    for(j=0; j<i; j++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73490:3: note: Loop condition is false. Execution continues on line 73507
  for(i=0; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73507:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73509:5: note: Loop condition is false. Execution continues on line 73512
    for(j=1; j<nNew; j++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73514:9: note: 'iBest' is equal to 'i'
    if( iBest!=i ){
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73514:5: note: Taking false branch
    if( iBest!=i ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73507:3: note: Loop condition is false. Execution continues on line 73536
  for(i=0; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73544:7: note: Assuming the condition is false
  if( (pageFlags & PTF_LEAF)==0 && nOld!=nNew ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73544:33: note: Left side of '&&' is false
  if( (pageFlags & PTF_LEAF)==0 && nOld!=nNew ){
                                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73565:7: note: Assuming field 'autoVacuum' is 0
  if( ISAUTOVACUUM ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:65102:22: note: expanded from macro 'ISAUTOVACUUM'
#define ISAUTOVACUUM (pBt->autoVacuum)
                     ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73565:3: note: Taking false branch
  if( ISAUTOVACUUM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73608:3: note: Loop condition is false. Execution continues on line 73689
  for(i=0; i<nNew-1; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73689:3: note: Loop condition is true.  Entering loop body
  for(i=1-nNew; i<nNew; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73690:15: note: 'i' is >= 0
    int iPg = i<0 ? -i : i;
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73690:15: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73692:5: note: Taking false branch
    if( abDone[iPg] ) continue;         /* Skip pages already processed */
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73693:9: note: 'i' is >= 0
    if( i>=0                            /* On the upwards pass, or... */
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73694:6: note: Left side of '||' is true
     || cntOld[iPg-1]>=cntNew[iPg-1]    /* Condition (1) is true */
     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73708:11: note: 'iPg' is equal to 0
      if( iPg==0 ){
          ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73708:7: note: Taking true branch
      if( iPg==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73717:12: note: Calling 'editPage'
      rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72687:7: note: 'iOld' is >= 'iNew'
  if( iOld<iNew ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72687:3: note: Taking false branch
  if( iOld<iNew ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72693:7: note: Assuming 'iNewEnd' is >= 'iOldEnd'
  if( iNewEnd < iOldEnd ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72693:3: note: Taking false branch
  if( iNewEnd < iOldEnd ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72700:7: note: Assuming 'pData' is >= 'pBegin'
  if( pData<pBegin ) goto editpage_fail;
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72700:3: note: Taking false branch
  if( pData<pBegin ) goto editpage_fail;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72703:7: note: 'iNew' is >= 'iOld'
  if( iNew<iOld ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72703:3: note: Taking false branch
  if( iNew<iOld ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72717:12: note: Assuming 'i' is >= field 'nOverflow'
  for(i=0; i<pPg->nOverflow; i++){
           ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72717:3: note: Loop condition is false. Execution continues on line 72734
  for(i=0; i<pPg->nOverflow; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72736:7: note: Calling 'pageInsertArray'
  if( pageInsertArray(
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72555:7: note: Assuming 'iEnd' is > 'iFirst'
  if( iEnd<=iFirst ) return 0;
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72555:3: note: Taking false branch
  if( iEnd<=iFirst ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72556:12: note: Assuming the condition is true
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
           ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72556:12: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72556:3: note: Loop condition is true.  Entering loop body
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72556:51: note: The value 1 is assigned to 'k'
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
                                                  ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72556:28: note: The left operand of '<=' is a garbage value
  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}
           ~~~~~~~~~~~~~~~~^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72581:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(pSlot, pCArray->apCell[i], sz);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72581:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
    memmove(pSlot, pCArray->apCell[i], sz);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72690:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift*2], nCell*2);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72690:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
    memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift*2], nCell*2);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72708:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(&pCellptr[nAdd*2], pCellptr, nCell*2);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72708:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
    memmove(&pCellptr[nAdd*2], pCellptr, nCell*2);
    ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72722:9: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72722:9: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
        memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72963:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72963:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72964:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:72964:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73064:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(abDone, 0, sizeof(abDone));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73064:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(abDone, 0, sizeof(abDone));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73121:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(apOld, 0, (i+1)*sizeof(MemPage*));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73121:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(apOld, 0, (i+1)*sizeof(MemPage*));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73127:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(apOld, 0, (i)*sizeof(MemPage*));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73127:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(apOld, 0, (i)*sizeof(MemPage*));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73162:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73162:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73246:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73246:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73283:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pTemp, apDiv[i], sz);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73283:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pTemp, apDiv[i], sz);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73292:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73292:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73546:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&apNew[nNew-1]->aData[8], &pOld->aData[8], 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73546:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&apNew[nNew-1]->aData[8], &pOld->aData[8], 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73622:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&pNew->aData[8], pCell, 4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73622:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&pNew->aData[8], pCell, 4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73857:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pChild->aiOvfl, pRoot->aiOvfl,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73857:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pChild->aiOvfl, pRoot->aiOvfl,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73859:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pChild->apOvfl, pRoot->apOvfl,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:73859:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pChild->apOvfl, pRoot->apOvfl,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74046:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(pDest + i, 0, iAmt - i);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74046:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(pDest + i, 0, iAmt - i);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74057:9: warning: Null pointer passed as 2nd argument to memory comparison function [clang-analyzer-unix.cstring.NullArg]
    if( memcmp(pDest, ((u8*)pX->pData) + iOffset, iAmt)!=0 ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 124:'  at line 91597
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91625:7: note: Assuming the condition is false
  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
      ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91625:29: note: Left side of '&&' is false
  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91649:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
      ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91649:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91650:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91650:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91654:18: note: Assuming the condition is false
  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91654:17: note: '?' condition is false
  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91655:7: note: Assuming the condition is false
  if( pData->flags & MEM_Zero ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91655:3: note: Taking false branch
  if( pData->flags & MEM_Zero ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91660:3: note: Null pointer value stored to 'x.pKey'
  x.pKey = 0;
  ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91661:8: note: Calling 'sqlite3BtreeInsert'
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:7: note: Assuming field 'eState' is not equal to CURSOR_FAULT
  if( pCur->eState==CURSOR_FAULT ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:3: note: Taking false branch
  if( pCur->eState==CURSOR_FAULT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:7: note: Assuming the condition is false
  if( pCur->curFlags & BTCF_Multiple ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:3: note: Taking false branch
  if( pCur->curFlags & BTCF_Multiple ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:7: note: Assuming field 'pKeyInfo' is not equal to null
  if( pCur->pKeyInfo==0 ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:3: note: Taking false branch
  if( pCur->pKeyInfo==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: 'loc' is equal to 0
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:19: note: Assuming the condition is false
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:5: note: Taking false branch
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74291:9: note: 'loc' is equal to 0
    if( loc==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74291:5: note: Taking true branch
    if( loc==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74293:11: note: Assuming 'pCur->info.nKey' is equal to 'pX->nKey'
      if( pCur->info.nKey==pX->nKey ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74293:7: note: Taking true branch
      if( pCur->info.nKey==pX->nKey ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74295:9: note: Null pointer value stored to 'x2.pData'
        x2.pData = pX->pKey;
        ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74298:16: note: Calling 'btreeOverwriteCell'
        return btreeOverwriteCell(pCur, &x2);
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74083:7: note: Assuming the condition is false
  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74083:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74084:7: note: Assuming the condition is false
   || pCur->info.pPayload < pPage->aData + pPage->cellOffset
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74083:3: note: Taking false branch
  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74089:8: note: Calling 'btreeOverwriteContent'
  rc = btreeOverwriteContent(pPage, pCur->info.pPayload, pX,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74039:7: note: Assuming 'nData' is > 0
  if( nData<=0 ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74039:3: note: Taking false branch
  if( nData<=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74049:9: note: Assuming 'nData' is >= 'iAmt'
    if( nData<iAmt ){
        ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74049:5: note: Taking false branch
    if( nData<iAmt ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74057:9: note: Null pointer passed as 2nd argument to memory comparison function
    if( memcmp(pDest, ((u8*)pX->pData) + iOffset, iAmt)!=0 ){
        ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74064:7: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memmove(pDest, ((u8*)pX->pData) + iOffset, iAmt);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74064:7: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
      memmove(pDest, ((u8*)pX->pData) + iOffset, iAmt);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74242:46: warning: The left operand of '+' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
       && pCur->info.nPayload==(u32)pX->nData+pX->nZero
                                             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 134:'  at line 92352
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92363:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
      ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92363:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92366:8: note: Assuming the condition is false
  rc = ExpandBlob(pIn2);
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:21784:27: note: expanded from macro 'ExpandBlob'
  #define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)
                          ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92366:8: note: '?' condition is false
  rc = ExpandBlob(pIn2);
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:21784:26: note: expanded from macro 'ExpandBlob'
  #define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92367:7: note: 'rc' is 0
  if( rc ) goto abort_due_to_error;
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92367:3: note: Taking false branch
  if( rc ) goto abort_due_to_error;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92374:9: note: Assuming the condition is false
      ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92374:8: note: '?' condition is false
      ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92372:8: note: Calling 'sqlite3BtreeInsert'
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:7: note: Assuming field 'eState' is not equal to CURSOR_FAULT
  if( pCur->eState==CURSOR_FAULT ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:3: note: Taking false branch
  if( pCur->eState==CURSOR_FAULT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:7: note: Assuming the condition is false
  if( pCur->curFlags & BTCF_Multiple ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:3: note: Taking false branch
  if( pCur->curFlags & BTCF_Multiple ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:7: note: Assuming field 'pKeyInfo' is equal to null
  if( pCur->pKeyInfo==0 ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:3: note: Taking true branch
  if( pCur->pKeyInfo==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74218:9: note: Assuming field 'hasIncrblobCur' is 0
    if( p->hasIncrblobCur ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74218:5: note: Taking false branch
    if( p->hasIncrblobCur ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74237:9: note: Assuming the condition is true
    if( (pCur->curFlags&BTCF_ValidNKey)!=0 && pX->nKey==pCur->info.nKey ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74237:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74237:47: note: Assuming 'pX->nKey' is equal to 'pCur->info.nKey'
    if( (pCur->curFlags&BTCF_ValidNKey)!=0 && pX->nKey==pCur->info.nKey ){
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74237:5: note: Taking true branch
    if( (pCur->curFlags&BTCF_ValidNKey)!=0 && pX->nKey==pCur->info.nKey ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74241:11: note: Assuming field 'nSize' is not equal to 0
      if( pCur->info.nSize!=0
          ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74241:11: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74242:46: note: The left operand of '+' is a garbage value
       && pCur->info.nPayload==(u32)pX->nData+pX->nZero
                                    ~~~~~~~~~^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74270:11: warning: Branch condition evaluates to a garbage value [clang-analyzer-core.uninitialized.Branch]
      if( pX->nMem ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 124:'  at line 91597
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91625:7: note: Assuming the condition is false
  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
      ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91625:29: note: Left side of '&&' is false
  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91649:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
      ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91649:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91650:7: note: Assuming the condition is false
  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91650:3: note: Taking false branch
  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91654:18: note: Assuming the condition is false
  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91654:17: note: '?' condition is false
  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91655:7: note: Assuming the condition is false
  if( pData->flags & MEM_Zero ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91655:3: note: Taking false branch
  if( pData->flags & MEM_Zero ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:91661:8: note: Calling 'sqlite3BtreeInsert'
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:7: note: Assuming field 'eState' is not equal to CURSOR_FAULT
  if( pCur->eState==CURSOR_FAULT ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74172:3: note: Taking false branch
  if( pCur->eState==CURSOR_FAULT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:7: note: Assuming the condition is false
  if( pCur->curFlags & BTCF_Multiple ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74201:3: note: Taking false branch
  if( pCur->curFlags & BTCF_Multiple ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:7: note: Assuming field 'pKeyInfo' is not equal to null
  if( pCur->pKeyInfo==0 ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74214:3: note: Taking false branch
  if( pCur->pKeyInfo==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: 'loc' is equal to 0
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:19: note: Assuming the condition is true
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74269:5: note: Taking true branch
    if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74270:11: note: Branch condition evaluates to a garbage value
      if( pX->nMem ){
          ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74352:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(newCell, oldCell, 4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74352:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(newCell, oldCell, 4);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74376:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(oldCell, newCell, szNew);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74376:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(oldCell, newCell, szNew);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74432:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(pCur->pKey, pX->pKey, pX->nKey);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74432:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(pCur->pKey, pX->pKey, pX->nKey);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74478:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(aOut, aIn, nIn);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74478:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(aOut, aIn, nIn);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74508:11: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memcpy(aOut, aIn, nCopy);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:74508:11: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
          memcpy(aOut, aIn, nCopy);
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76208:10: warning: Access to field 'sharable' results in a dereference of a null pointer (loaded from variable 'p') [clang-analyzer-core.NullDereference]
  return p->sharable;
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:161534:3: note: Control jumps to 'case 3:'  at line 161554
  switch( yyruleno ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:161555:2: note: Calling 'sqlite3BeginTransaction'
{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy376);}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117238:3: note: Taking false branch
  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "BEGIN", 0, 0) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117242:8: note: 'v' is non-null
  if( !v ) return;
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117242:3: note: Taking false branch
  if( !v ) return;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117243:7: note: Assuming 'type' is not equal to TK_DEFERRED
  if( type!=TK_DEFERRED ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117243:3: note: Taking true branch
  if( type!=TK_DEFERRED ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117244:14: note: Assuming 'i' is < field 'nDb'
    for(i=0; i<db->nDb; i++){
             ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117244:5: note: Loop condition is true.  Entering loop body
    for(i=0; i<db->nDb; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117247:11: note: Assuming 'pBt' is null
      if( pBt && sqlite3BtreeIsReadonly(pBt) ){
          ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117247:15: note: Left side of '&&' is false
      if( pBt && sqlite3BtreeIsReadonly(pBt) ){
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117249:17: note: Assuming 'type' is not equal to TK_EXCLUSIVE
      }else if( type==TK_EXCLUSIVE ){
                ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117249:13: note: Taking false branch
      }else if( type==TK_EXCLUSIVE ){
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117255:7: note: Calling 'sqlite3VdbeUsesBtree'
      sqlite3VdbeUsesBtree(v, i);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:80669:7: note: 'i' is not equal to 1
  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:80669:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:80669:36: note: Passing null pointer value via 1st parameter 'p'
  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){
                                   ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:80669:15: note: Calling 'sqlite3BtreeSharable'
  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76208:10: note: Access to field 'sharable' results in a dereference of a null pointer (loaded from variable 'p')
  return p->sharable;
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76311:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sParse, 0, sizeof(sParse));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76311:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sParse, 0, sizeof(sParse));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76499:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zOut, zIn, nCopy);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76499:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zOut, zIn, nCopy);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76966:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&b, 0, sizeof(b));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:76966:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&b, 0, sizeof(b));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77268:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pMem->zMalloc, pMem->z, pMem->n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77268:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pMem->zMalloc, pMem->z, pMem->n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77300:11: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
  pMem->z = pMem->zMalloc;
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 137:'  at line 92483
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92505:13: note: 'rc' is equal to 0
  if( NEVER(rc!=SQLITE_OK) ) goto abort_due_to_error;
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13947:26: note: expanded from macro 'NEVER'
# define NEVER(X)       (X)
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92505:3: note: Taking false branch
  if( NEVER(rc!=SQLITE_OK) ) goto abort_due_to_error;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92507:7: note: Assuming field 'nullRow' is 0
  if( !pC->nullRow ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92507:3: note: Taking true branch
  if( !pC->nullRow ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92509:10: note: Calling 'sqlite3VdbeIdxRowid'
    rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:83825:3: note: Calling 'sqlite3VdbeMemInit'
  sqlite3VdbeMemInit(&m, db, 0);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77808:1: note: Returning without writing to 'pMem->zMalloc'
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:83825:3: note: Returning from 'sqlite3VdbeMemInit'
  sqlite3VdbeMemInit(&m, db, 0);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:83826:8: note: Calling 'sqlite3VdbeMemFromBtreeZeroOffset'
  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78217:7: note: Assuming 'amt' is > 'available'
  if( amt<=available ){
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78217:3: note: Taking false branch
  if( amt<=available ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78221:10: note: Calling 'sqlite3VdbeMemFromBtree'
    rc = sqlite3VdbeMemFromBtree(pCur, 0, amt, pMem);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78185:7: note: Assuming the condition is false
  if( sqlite3BtreeMaxRecordSize(pCur)<offset+amt ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78185:3: note: Taking false branch
  if( sqlite3BtreeMaxRecordSize(pCur)<offset+amt ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78188:24: note: Calling 'sqlite3VdbeMemClearAndResize'
  if( SQLITE_OK==(rc = sqlite3VdbeMemClearAndResize(pMem, amt+1)) ){
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77296:7: note: Assuming 'szNew' is <= field 'szMalloc'
  if( pMem->szMalloc<szNew ){
      ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77296:3: note: Taking false branch
  if( pMem->szMalloc<szNew ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77300:11: note: Assigned value is garbage or undefined
  pMem->z = pMem->zMalloc;
          ^ ~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77372:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77372:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77448:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&ctx, 0, sizeof(ctx));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77448:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&ctx, 0, sizeof(ctx));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77449:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&t, 0, sizeof(t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77449:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&t, 0, sizeof(t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77458:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pMem, &t, sizeof(t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77458:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pMem, &t, sizeof(t));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77477:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&ctx, 0, sizeof(ctx));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:77477:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&ctx, 0, sizeof(ctx));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78008:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pTo, pFrom, MEMCELLSIZE);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78008:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pTo, pFrom, MEMCELLSIZE);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78025:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pTo, pFrom, MEMCELLSIZE);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78025:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pTo, pFrom, MEMCELLSIZE);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78049:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pTo, pFrom, sizeof(Mem));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78049:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pTo, pFrom, sizeof(Mem));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78123:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pMem->z, z, nAlloc);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78123:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pMem->z, z, nAlloc);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78939:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:78939:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:79052:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:79052:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:79308:16: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  if( p4copy ) memcpy(p4copy, zP4, 8);
               ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:79308:16: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  if( p4copy ) memcpy(p4copy, zP4, 8);
               ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:81363:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:81363:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:82713:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&v, &pMem->u.r, sizeof(v));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:82713:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&v, &pMem->u.r, sizeof(v));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:82732:17: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    if( len>0 ) memcpy(buf, pMem->z, len);
                ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:82732:17: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    if( len>0 ) memcpy(buf, pMem->z, len);
                ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:82789:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&pMem->u.r, &x, sizeof(x));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:82789:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&pMem->u.r, &x, sizeof(x));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:84494:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pNew, 0, sizeof(*pNew));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:84494:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pNew, 0, sizeof(*pNew));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:84495:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pNew, pOrig, MEMCELLSIZE);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:84495:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pNew, pOrig, MEMCELLSIZE);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:85032:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(pMem->z, 0, nByte);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:85032:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(pMem->z, 0, nByte);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86356:11: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memset(&utf8, 0, sizeof(utf8));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86356:11: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
          memset(&utf8, 0, sizeof(utf8));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86405:3: warning: Address of stack memory associated with local variable 'zBase' returned to caller [clang-analyzer-core.StackAddressEscape]
  return sqlite3StrAccumFinish(&out);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:85919:7: note: Assuming 'zSql' is non-null
  if( zSql ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:85919:3: note: Taking true branch
  if( zSql ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:85922:9: note: Calling 'sqlite3VdbeExpandSql'
    z = sqlite3VdbeExpandSql(p, zSql);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86306:7: note: Assuming field 'nVdbeExec' is > 1
  if( db->nVdbeExec>1 ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86306:3: note: Taking true branch
  if( db->nVdbeExec>1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86307:5: note: Loop condition is false. Execution continues on line 86404
    while( *zRawSql ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86404:11: note: Field 'accError' is 0
  if( out.accError ) sqlite3_str_reset(&out);
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86404:3: note: Taking false branch
  if( out.accError ) sqlite3_str_reset(&out);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86405:3: note: Address of stack memory associated with local variable 'zBase' returned to caller
  return sqlite3StrAccumFinish(&out);
  ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86710:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pCx, 0, offsetof(VdbeCursor,pAltCursor));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86710:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pCx, 0, offsetof(VdbeCursor,pAltCursor));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87845:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pOut, pVar, MEMCELLSIZE);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87845:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pOut, pVar, MEMCELLSIZE);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:88097:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pOut->z, pIn2->z, pIn2->n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:88097:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pOut->z, pIn2->z, pIn2->n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:88101:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:88101:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:88325:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&uA, &iA, sizeof(uA));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:88325:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&uA, &iA, sizeof(uA));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:88333:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&iA, &uA, sizeof(iA));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:88333:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&iA, &uA, sizeof(iA));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:89226:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(&sMem, 0, sizeof(sMem));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:89226:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(&sMem, 0, sizeof(sMem));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:89324:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pDest->z, zData, len);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:89324:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pDest->z, zData, len);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:89798:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(pNew->zName, zName, nName+1);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:89798:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(pNew->zName, zName, nName+1);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:93261:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pFrame->aOnce, 0, (pProgram->nOp + 7)/8);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:93261:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pFrame->aOnce, 0, (pProgram->nOp + 7)/8);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:93983:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sMem, 0, sizeof(sMem));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:93983:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sMem, 0, sizeof(sMem));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:94110:3: warning: Value stored to 'res' is never read [clang-analyzer-deadcode.DeadStores]
  res = 0;
  ^     ~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:94110:3: note: Value stored to 'res' is never read
  res = 0;
  ^     ~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:94159:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sContext, 0, sizeof(sContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:94159:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sContext, 0, sizeof(sContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:94200:3: warning: Value stored to 'res' is never read [clang-analyzer-deadcode.DeadStores]
  res = 0;
  ^     ~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:94200:3: note: Value stored to 'res' is never read
  res = 0;
  ^     ~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:94958:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sParse, 0, sizeof(Parse));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:94958:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sParse, 0, sizeof(Parse));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:95791:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pReadr, 0, sizeof(PmaReader));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:95791:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pReadr, 0, sizeof(PmaReader));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:95867:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:95867:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:95883:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:95883:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96292:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96292:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96382:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pTask, 0, sizeof(SortSubtask));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96382:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pTask, 0, sizeof(SortSubtask));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96729:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(aSlot, 0, sizeof(aSlot));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96729:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(aSlot, 0, sizeof(aSlot));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96775:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(PmaWriter));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96775:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(PmaWriter));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96799:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96799:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96835:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(PmaWriter));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96835:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(PmaWriter));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96876:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&writer, 0, sizeof(PmaWriter));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:96876:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&writer, 0, sizeof(PmaWriter));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97058:14: warning: Dereference of null pointer [clang-analyzer-core.NullDereference]
      aMem = pTask->list.aMemory;
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:7: note: Assuming field 'xProgress' is null
  if( db->xProgress ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87212:3: note: Taking false branch
  if( db->xProgress ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:7: note: Assuming field 'rc' is not equal to SQLITE_NOMEM
  if( p->rc==SQLITE_NOMEM ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87220:3: note: Taking false branch
  if( p->rc==SQLITE_NOMEM ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:7: note: Assuming the condition is false
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13686:32: note: expanded from macro 'AtomicLoad'
# define AtomicLoad(PTR)       (*(PTR))
                               ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87233:3: note: Taking false branch
  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87262:3: note: Loop condition is true.  Entering loop body
  for(pOp=&aOp[p->pc]; 1; pOp++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:87339:5: note: Control jumps to 'case 37:'  at line 92184
    switch( pOp->opcode ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92198:7: note: Assuming field 'eCurType' is equal to 1
  if( isSorter(pC) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:86645:22: note: expanded from macro 'isSorter'
#define isSorter(x) ((x)->eCurType==CURTYPE_SORTER)
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92198:3: note: Taking true branch
  if( isSorter(pC) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:92199:10: note: Calling 'sqlite3VdbeSorterRewind'
    rc = sqlite3VdbeSorterRewind(pC, &res);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97908:7: note: Assuming field 'bUsePMA' is not equal to 0
  if( pSorter->bUsePMA==0 ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97908:3: note: Taking false branch
  if( pSorter->bUsePMA==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97923:8: note: Calling 'vdbeSorterFlushPMA'
  rc = vdbeSorterFlushPMA(pSorter);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97020:3: note: 'pTask' initialized to a null pointer value
  SortSubtask *pTask = 0;    /* Thread context used to create new PMA */
  ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97035:12: note: Assuming 'i' is >= 'nWorker'
  for(i=0; i<nWorker; i++){
           ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97035:3: note: Loop condition is false. Execution continues on line 97044
  for(i=0; i<nWorker; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97044:7: note: 'rc' is equal to SQLITE_OK
  if( rc==SQLITE_OK ){
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97044:3: note: Taking true branch
  if( rc==SQLITE_OK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97045:9: note: Assuming 'i' is not equal to 'nWorker'
    if( i==nWorker ){
        ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97045:5: note: Taking false branch
    if( i==nWorker ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97058:14: note: Dereference of null pointer
      aMem = pTask->list.aMemory;
             ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97183:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(SRVAL(pNew), pVal->z, pVal->n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:97183:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(SRVAL(pNew), pVal->z, pVal->n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98026:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pOut->z, pKey, nKey);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98026:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pOut->z, pKey, nKey);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98630:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98630:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98630:5: warning: Null pointer passed as 2nd argument to memory copy function [clang-analyzer-unix.cstring.NullArg]
    memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);
    ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98609:7: note: Assuming the condition is false
  if( (iAmt+iOfst)>p->endpoint.iOffset ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98609:3: note: Taking false branch
  if( (iAmt+iOfst)>p->endpoint.iOffset ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98613:7: note: Assuming 'iOfst' is not equal to field 'iOffset'
  if( p->readpoint.iOffset!=iOfst || iOfst==0 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98613:35: note: Left side of '||' is true
  if( p->readpoint.iOffset!=iOfst || iOfst==0 ){
                                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98616:9: note: Assuming 'pChunk' is null
        ALWAYS(pChunk) && (iOff+p->nChunkSize)<=iOfst;
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13946:25: note: expanded from macro 'ALWAYS'
# define ALWAYS(X)      (X)
                        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98616:24: note: Left side of '&&' is false
        ALWAYS(pChunk) && (iOff+p->nChunkSize)<=iOfst;
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98629:17: note: Assuming the condition is true
    int nCopy = MIN(nRead, (p->nChunkSize - iChunkOffset));
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14476:20: note: expanded from macro 'MIN'
# define MIN(A,B) ((A)<(B)?(A):(B))
                   ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98629:17: note: '?' condition is true
    int nCopy = MIN(nRead, (p->nChunkSize - iChunkOffset));
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14476:20: note: expanded from macro 'MIN'
# define MIN(A,B) ((A)<(B)?(A):(B))
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98630:5: note: Null pointer passed as 2nd argument to memory copy function
    memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);
    ^            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98661:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(MemJournal));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98661:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(MemJournal));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98755:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy((u8*)p->endpoint.pChunk->zChunk + iChunkOffset, zWrite, iSpace);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98755:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy((u8*)p->endpoint.pChunk->zChunk + iChunkOffset, zWrite, iSpace);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98875:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(MemJournal));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:98875:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(MemJournal));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99252:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&w, 0, sizeof(w));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99252:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&w, 0, sizeof(w));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99312:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pExpr, pDup, sizeof(*pExpr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99312:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pExpr, pDup, sizeof(*pExpr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:100467:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&nc, 0, sizeof(nc));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:100467:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&nc, 0, sizeof(nc));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:100686:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sWalker, 0, sizeof(Walker));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:100686:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sWalker, 0, sizeof(Walker));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:100823:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sNC, 0, sizeof(sNC));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:100823:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sNC, 0, sizeof(sNC));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101205:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101205:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101206:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sSrc, 0, sizeof(sSrc));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101206:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sSrc, 0, sizeof(sSrc));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101651:12: warning: Access to field 'nExpr' results in a dereference of a null pointer (loaded from field 'pList') [clang-analyzer-core.NullDereference]
    return pExpr->x.pList->nExpr;
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146451:7: note: Assuming field 'iFrom' is <= 0
  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146451:23: note: Left side of '&&' is false
  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146459:17: note: Assuming 'j' is <= 0
  for(j=iLevel; j>0 && pWInfo->a[j].iLeftJoin==0; j--){}
                ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146459:21: note: Left side of '&&' is false
  for(j=iLevel; j>0 && pWInfo->a[j].iLeftJoin==0; j--){}
                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146463:7: note: Assuming field 'viaCoroutine' is 0
  if( pTabItem->fg.viaCoroutine ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146463:3: note: Taking false branch
  if( pTabItem->fg.viaCoroutine ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146473:8: note: Assuming the condition is false
  if(  (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146473:3: note: Taking false branch
  if(  (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:7: note: Assuming the condition is true
  if( (pLoop->wsFlags & WHERE_IPK)!=0
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146567:7: note: Assuming the condition is true
   && (pLoop->wsFlags & (WHERE_COLUMN_IN|WHERE_COLUMN_EQ))!=0
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:3: note: Taking true branch
  if( (pLoop->wsFlags & WHERE_IPK)!=0
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146580:17: note: Calling 'codeEqualityTerm'
    iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:7: note: Assuming field 'op' is not equal to TK_EQ
  if( pX->op==TK_EQ || pX->op==TK_IS ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:24: note: Assuming field 'op' is not equal to TK_IS
  if( pX->op==TK_EQ || pX->op==TK_IS ){
                       ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:3: note: Taking false branch
  if( pX->op==TK_EQ || pX->op==TK_IS ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145591:13: note: Assuming field 'op' is not equal to TK_ISNULL
  }else if( pX->op==TK_ISNULL ){
            ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145591:9: note: Taking false branch
  }else if( pX->op==TK_ISNULL ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145604:9: note: Left side of '&&' is true
    if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145605:10: note: Assuming field 'pIndex' is equal to null
      && pLoop->u.btree.pIndex!=0
         ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145606:7: note: Left side of '&&' is false
      && pLoop->u.btree.pIndex->aSortOrder[iEq]
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145615:5: note: Loop condition is false. Execution continues on line 145621
    for(i=0; i<iEq; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145621:15: note: Assuming 'i' is >= field 'nLTerm'
    for(i=iEq;i<pLoop->nLTerm; i++){
              ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145621:5: note: Loop condition is false. Execution continues on line 145626
    for(i=iEq;i<pLoop->nLTerm; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:9: note: Assuming the condition is false
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:42: note: Assuming field 'nExpr' is not equal to 1
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:5: note: Taking false branch
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145631:12: note: Calling 'removeUnindexableInClauseTerms'
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145502:7: note: Assuming field 'mallocFailed' is equal to 0
  if( db->mallocFailed==0 ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145502:3: note: Taking true branch
  if( db->mallocFailed==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145506:5: note: 'pLhs' initialized to a null pointer value
    ExprList *pLhs = 0;         /* New LHS after mods */
    ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145510:5: note: Loop condition is false. Execution continues on line 145521
    for(i=iEq; i<pLoop->nLTerm; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145523:5: note: Null pointer value stored to field 'pList'
    pNew->pLeft->x.pList = pLhs;
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145525:9: note: 'pLhs' is null
    if( pLhs && pLhs->nExpr==1 ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145525:14: note: Left side of '&&' is false
    if( pLhs && pLhs->nExpr==1 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145535:9: note: Assuming field 'pOrderBy' is null
    if( pSelect->pOrderBy ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145535:5: note: Taking false branch
    if( pSelect->pOrderBy ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145631:12: note: Returning from 'removeUnindexableInClauseTerms'
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145633:16: note: Field 'mallocFailed' is 0
      if( !db->mallocFailed ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145633:7: note: Taking true branch
      if( !db->mallocFailed ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145635:17: note: Calling 'sqlite3FindInIndex'
        eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap, &iTab);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103842:7: note: 'prRhsHasNull' is null
  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103842:20: note: Left side of '&&' is false
  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103856:7: note: Assuming field 'nErr' is not equal to 0
  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103856:23: note: Left side of '&&' is false
  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103996:7: note: 'eType' is equal to 0
  if( eType==0
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103996:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103998:4: note: Left side of '&&' is false
   && !ExprHasProperty(pX, EP_xIsSelect)
   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104004:7: note: 'eType' is equal to 0
  if( eType==0 ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104004:3: note: Taking true branch
  if( eType==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104011:5: note: Taking true branch
    if( inFlags & IN_INDEX_LOOP ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104017:5: note: Calling 'sqlite3CodeRhsOfIN'
    sqlite3CodeRhsOfIN(pParse, pX, iTab);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104153:8: note: Assuming the condition is false
  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:35: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104153:7: note: Left side of '&&' is true
  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104153:48: note: Assuming field 'iSelfTab' is not equal to 0
  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
                                               ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104153:3: note: Taking false branch
  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104184:10: note: Calling 'sqlite3ExprVectorSize'
  nVal = sqlite3ExprVectorSize(pLeft);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101649:7: note: Assuming 'op' is not equal to TK_REGISTER
  if( op==TK_REGISTER ) op = pExpr->op2;
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101649:3: note: Taking false branch
  if( op==TK_REGISTER ) op = pExpr->op2;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101650:7: note: Assuming 'op' is equal to TK_VECTOR
  if( op==TK_VECTOR ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101650:3: note: Taking true branch
  if( op==TK_VECTOR ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:101651:12: note: Access to field 'nExpr' results in a dereference of a null pointer (loaded from field 'pList')
    return pExpr->x.pList->nExpr;
           ^        ~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102061:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pNew, 0, sizeof(Expr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102061:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pNew, 0, sizeof(Expr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102071:25: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);
                        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102071:25: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);
                        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102145:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(p, 0, sizeof(Expr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102145:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(p, 0, sizeof(Expr));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102569:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zAlloc, p, nNewSize);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102569:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zAlloc, p, nNewSize);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102572:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zAlloc, p, nSize);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102572:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zAlloc, p, nSize);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102574:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102574:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102590:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zToken, p->u.zToken, nToken);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102590:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zToken, p->u.zToken, nToken);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103694:14: warning: Access to field 'nExpr' results in a dereference of a null pointer (loaded from variable 'pEList') [clang-analyzer-core.NullDereference]
  for(i=0; i<pEList->nExpr; i++){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146451:7: note: Assuming field 'iFrom' is <= 0
  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146451:23: note: Left side of '&&' is false
  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146459:17: note: Assuming 'j' is <= 0
  for(j=iLevel; j>0 && pWInfo->a[j].iLeftJoin==0; j--){}
                ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146459:21: note: Left side of '&&' is false
  for(j=iLevel; j>0 && pWInfo->a[j].iLeftJoin==0; j--){}
                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146463:7: note: Assuming field 'viaCoroutine' is 0
  if( pTabItem->fg.viaCoroutine ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146463:3: note: Taking false branch
  if( pTabItem->fg.viaCoroutine ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146473:8: note: Assuming the condition is false
  if(  (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146473:3: note: Taking false branch
  if(  (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:7: note: Assuming the condition is true
  if( (pLoop->wsFlags & WHERE_IPK)!=0
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146567:7: note: Assuming the condition is true
   && (pLoop->wsFlags & (WHERE_COLUMN_IN|WHERE_COLUMN_EQ))!=0
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:3: note: Taking true branch
  if( (pLoop->wsFlags & WHERE_IPK)!=0
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146580:17: note: Calling 'codeEqualityTerm'
    iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:7: note: Assuming field 'op' is not equal to TK_EQ
  if( pX->op==TK_EQ || pX->op==TK_IS ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:24: note: Assuming field 'op' is not equal to TK_IS
  if( pX->op==TK_EQ || pX->op==TK_IS ){
                       ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:3: note: Taking false branch
  if( pX->op==TK_EQ || pX->op==TK_IS ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145591:13: note: Assuming field 'op' is not equal to TK_ISNULL
  }else if( pX->op==TK_ISNULL ){
            ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145591:9: note: Taking false branch
  }else if( pX->op==TK_ISNULL ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145604:9: note: Left side of '&&' is true
    if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145605:10: note: Assuming field 'pIndex' is equal to null
      && pLoop->u.btree.pIndex!=0
         ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145606:7: note: Left side of '&&' is false
      && pLoop->u.btree.pIndex->aSortOrder[iEq]
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145615:5: note: Loop condition is false. Execution continues on line 145621
    for(i=0; i<iEq; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145621:15: note: Assuming 'i' is >= field 'nLTerm'
    for(i=iEq;i<pLoop->nLTerm; i++){
              ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145621:5: note: Loop condition is false. Execution continues on line 145626
    for(i=iEq;i<pLoop->nLTerm; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:9: note: Assuming the condition is false
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:42: note: Assuming field 'nExpr' is not equal to 1
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:5: note: Taking false branch
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145631:12: note: Calling 'removeUnindexableInClauseTerms'
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145502:7: note: Assuming field 'mallocFailed' is equal to 0
  if( db->mallocFailed==0 ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145502:3: note: Taking true branch
  if( db->mallocFailed==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145505:5: note: 'pRhs' initialized to a null pointer value
    ExprList *pRhs = 0;         /* New RHS after modifications */
    ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145510:5: note: Loop condition is false. Execution continues on line 145521
    for(i=iEq; i<pLoop->nLTerm; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145524:5: note: Null pointer value stored to field 'pEList'
    pNew->x.pSelect->pEList = pRhs;
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145525:9: note: 'pLhs' is null
    if( pLhs && pLhs->nExpr==1 ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145525:14: note: Left side of '&&' is false
    if( pLhs && pLhs->nExpr==1 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145535:9: note: Assuming field 'pOrderBy' is null
    if( pSelect->pOrderBy ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145535:5: note: Taking false branch
    if( pSelect->pOrderBy ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145631:12: note: Returning from 'removeUnindexableInClauseTerms'
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145633:16: note: Field 'mallocFailed' is 0
      if( !db->mallocFailed ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145633:7: note: Taking true branch
      if( !db->mallocFailed ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145635:17: note: Calling 'sqlite3FindInIndex'
        eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap, &iTab);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103842:7: note: 'prRhsHasNull' is null
  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103842:20: note: Left side of '&&' is false
  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103856:7: note: Assuming field 'nErr' is equal to 0
  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103856:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103856:31: note: Calling 'isCandidateForInOpt'
  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
                              ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103671:8: note: Assuming the condition is true
  if( !ExprHasProperty(pX, EP_xIsSelect) ) return 0;  /* Not a subquery */
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:35: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103671:3: note: Taking false branch
  if( !ExprHasProperty(pX, EP_xIsSelect) ) return 0;  /* Not a subquery */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103672:7: note: Assuming the condition is false
  if( ExprHasProperty(pX, EP_VarSelect)  ) return 0;  /* Correlated subq */
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:35: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103672:3: note: Taking false branch
  if( ExprHasProperty(pX, EP_VarSelect)  ) return 0;  /* Correlated subq */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103674:7: note: Assuming field 'pPrior' is null
  if( p->pPrior ) return 0;              /* Not a compound SELECT */
      ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103674:3: note: Taking false branch
  if( p->pPrior ) return 0;              /* Not a compound SELECT */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103675:7: note: Assuming the condition is false
  if( p->selFlags & (SF_Distinct|SF_Aggregate) ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103675:3: note: Taking false branch
  if( p->selFlags & (SF_Distinct|SF_Aggregate) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103681:7: note: Assuming field 'pLimit' is null
  if( p->pLimit ) return 0;              /* Has no LIMIT clause */
      ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103681:3: note: Taking false branch
  if( p->pLimit ) return 0;              /* Has no LIMIT clause */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103682:7: note: Assuming field 'pWhere' is null
  if( p->pWhere ) return 0;              /* Has no WHERE clause */
      ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103682:3: note: Taking false branch
  if( p->pWhere ) return 0;              /* Has no WHERE clause */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103685:7: note: Assuming field 'nSrc' is equal to 1
  if( pSrc->nSrc!=1 ) return 0;          /* Single term in FROM clause */
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103685:3: note: Taking false branch
  if( pSrc->nSrc!=1 ) return 0;          /* Single term in FROM clause */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103686:7: note: Assuming field 'pSelect' is null
  if( pSrc->a[0].pSelect ) return 0;     /* FROM is not a subquery or view */
      ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103686:3: note: Taking false branch
  if( pSrc->a[0].pSelect ) return 0;     /* FROM is not a subquery or view */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103690:7: note: Assuming field 'nModuleArg' is 0
  if( IsVirtual(pTab) ) return 0;        /* FROM clause not a virtual table */
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17837:29: note: expanded from macro 'IsVirtual'
#  define IsVirtual(X)      ((X)->nModuleArg)
                            ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103690:3: note: Taking false branch
  if( IsVirtual(pTab) ) return 0;        /* FROM clause not a virtual table */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103691:3: note: Null pointer value stored to 'pEList'
  pEList = p->pEList;
  ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103694:14: note: Access to field 'nExpr' results in a dereference of a null pointer (loaded from variable 'pEList')
  for(i=0; i<pEList->nExpr; i++){
             ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104214:16: warning: Access to field 'nExpr' results in a dereference of a null pointer (loaded from variable 'pEList') [clang-analyzer-core.NullDereference]
    if( ALWAYS(pEList->nExpr==nVal) ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146451:7: note: Assuming field 'iFrom' is <= 0
  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146451:23: note: Left side of '&&' is false
  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146459:17: note: Assuming 'j' is <= 0
  for(j=iLevel; j>0 && pWInfo->a[j].iLeftJoin==0; j--){}
                ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146459:21: note: Left side of '&&' is false
  for(j=iLevel; j>0 && pWInfo->a[j].iLeftJoin==0; j--){}
                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146463:7: note: Assuming field 'viaCoroutine' is 0
  if( pTabItem->fg.viaCoroutine ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146463:3: note: Taking false branch
  if( pTabItem->fg.viaCoroutine ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146473:8: note: Assuming the condition is false
  if(  (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146473:3: note: Taking false branch
  if(  (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:7: note: Assuming the condition is true
  if( (pLoop->wsFlags & WHERE_IPK)!=0
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146567:7: note: Assuming the condition is true
   && (pLoop->wsFlags & (WHERE_COLUMN_IN|WHERE_COLUMN_EQ))!=0
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146566:3: note: Taking true branch
  if( (pLoop->wsFlags & WHERE_IPK)!=0
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146580:17: note: Calling 'codeEqualityTerm'
    iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:7: note: Assuming field 'op' is not equal to TK_EQ
  if( pX->op==TK_EQ || pX->op==TK_IS ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:24: note: Assuming field 'op' is not equal to TK_IS
  if( pX->op==TK_EQ || pX->op==TK_IS ){
                       ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145589:3: note: Taking false branch
  if( pX->op==TK_EQ || pX->op==TK_IS ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145591:13: note: Assuming field 'op' is not equal to TK_ISNULL
  }else if( pX->op==TK_ISNULL ){
            ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145591:9: note: Taking false branch
  }else if( pX->op==TK_ISNULL ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145604:9: note: Left side of '&&' is true
    if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145605:10: note: Assuming field 'pIndex' is equal to null
      && pLoop->u.btree.pIndex!=0
         ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145606:7: note: Left side of '&&' is false
      && pLoop->u.btree.pIndex->aSortOrder[iEq]
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145615:5: note: Loop condition is false. Execution continues on line 145621
    for(i=0; i<iEq; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145621:15: note: Assuming 'i' is >= field 'nLTerm'
    for(i=iEq;i<pLoop->nLTerm; i++){
              ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145621:5: note: Loop condition is false. Execution continues on line 145626
    for(i=iEq;i<pLoop->nLTerm; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:9: note: Assuming the condition is false
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:42: note: Assuming field 'nExpr' is not equal to 1
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145627:5: note: Taking false branch
    if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145631:12: note: Calling 'removeUnindexableInClauseTerms'
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145502:7: note: Assuming field 'mallocFailed' is equal to 0
  if( db->mallocFailed==0 ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145502:3: note: Taking true branch
  if( db->mallocFailed==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145505:5: note: 'pRhs' initialized to a null pointer value
    ExprList *pRhs = 0;         /* New RHS after modifications */
    ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145510:5: note: Loop condition is false. Execution continues on line 145521
    for(i=iEq; i<pLoop->nLTerm; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145524:5: note: Null pointer value stored to field 'pEList'
    pNew->x.pSelect->pEList = pRhs;
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145525:9: note: 'pLhs' is null
    if( pLhs && pLhs->nExpr==1 ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145525:14: note: Left side of '&&' is false
    if( pLhs && pLhs->nExpr==1 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145535:9: note: Assuming field 'pOrderBy' is null
    if( pSelect->pOrderBy ){
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145535:5: note: Taking false branch
    if( pSelect->pOrderBy ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145631:12: note: Returning from 'removeUnindexableInClauseTerms'
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145633:16: note: Field 'mallocFailed' is 0
      if( !db->mallocFailed ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145633:7: note: Taking true branch
      if( !db->mallocFailed ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:145635:17: note: Calling 'sqlite3FindInIndex'
        eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap, &iTab);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103842:7: note: 'prRhsHasNull' is null
  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103842:20: note: Left side of '&&' is false
  if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103856:7: note: Assuming field 'nErr' is not equal to 0
  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103856:23: note: Left side of '&&' is false
  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103996:7: note: 'eType' is equal to 0
  if( eType==0
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103996:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103998:4: note: Left side of '&&' is false
   && !ExprHasProperty(pX, EP_xIsSelect)
   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104004:7: note: 'eType' is equal to 0
  if( eType==0 ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104004:3: note: Taking true branch
  if( eType==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104011:5: note: Taking true branch
    if( inFlags & IN_INDEX_LOOP ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104017:5: note: Calling 'sqlite3CodeRhsOfIN'
    sqlite3CodeRhsOfIN(pParse, pX, iTab);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104153:8: note: Assuming the condition is false
  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:35: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104153:7: note: Left side of '&&' is true
  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104153:48: note: Assuming field 'iSelfTab' is not equal to 0
  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
                                               ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104153:3: note: Taking false branch
  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104200:7: note: Assuming the condition is true
  if( ExprHasProperty(pExpr, EP_xIsSelect) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:35: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104200:3: note: Taking true branch
  if( ExprHasProperty(pExpr, EP_xIsSelect) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104207:5: note: 'pEList' initialized to a null pointer value
    ExprList *pEList = pSelect->pEList;
    ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104210:9: note: 'addrOnce' is 0
        addrOnce?"":"CORRELATED ", pSelect->selId
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:16082:56: note: expanded from macro 'ExplainQueryPlan'
# define ExplainQueryPlan(P)        sqlite3VdbeExplain P
                                                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104210:9: note: '?' condition is false
        addrOnce?"":"CORRELATED ", pSelect->selId
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104214:16: note: Access to field 'nExpr' results in a dereference of a null pointer (loaded from variable 'pEList')
    if( ALWAYS(pEList->nExpr==nVal) ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13946:26: note: expanded from macro 'ALWAYS'
# define ALWAYS(X)      (X)
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104998:11: warning: Access to field 'nExpr' results in a dereference of a null pointer (loaded from variable 'pFarg') [clang-analyzer-core.NullDereference]
  nFarg = pFarg->nExpr;
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105118:7: note: Assuming 'pExpr' is not equal to null
  if( pExpr==0 ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105118:3: note: Taking false branch
  if( pExpr==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105124:3: note: Control jumps to 'case 171:'  at line 105448
  switch( op ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105460:11: note: Assuming the condition is false
      if( ExprHasProperty(pExpr, EP_WinFunc) ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:35: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105460:7: note: Taking false branch
      if( ExprHasProperty(pExpr, EP_WinFunc) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105465:11: note: Assuming field 'okConstFactor' is 0
      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17337:26: note: expanded from macro 'ConstFactorOk'
#define ConstFactorOk(P) ((P)->okConstFactor)
                         ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105465:33: note: Left side of '&&' is false
      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){
                                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105472:7: note: Value assigned to 'pFarg'
      pFarg = pExpr->x.pList;
      ^~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105473:15: note: Assuming 'pFarg' is null
      nFarg = pFarg ? pFarg->nExpr : 0;
              ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105473:15: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105482:11: note: Assuming 'pDef' is not equal to null
      if( pDef==0 || pDef->xFinalize!=0 ){
          ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105482:11: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105482:22: note: Assuming field 'xFinalize' is equal to null
      if( pDef==0 || pDef->xFinalize!=0 ){
                     ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105482:7: note: Taking false branch
      if( pDef==0 || pDef->xFinalize!=0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105486:11: note: Assuming the condition is true
      if( pDef->funcFlags & SQLITE_FUNC_INLINE ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105486:7: note: Taking true branch
      if( pDef->funcFlags & SQLITE_FUNC_INLINE ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105489:47: note: Passing null pointer value via 2nd parameter 'pFarg'
        return exprCodeInlineFunction(pParse, pFarg,
                                              ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105489:16: note: Calling 'exprCodeInlineFunction'
        return exprCodeInlineFunction(pParse, pFarg,
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:104998:11: note: Access to field 'nExpr' results in a dereference of a null pointer (loaded from variable 'pFarg')
  nFarg = pFarg->nExpr;
          ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105021:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&caseExpr, 0, sizeof(caseExpr));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105021:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&caseExpr, 0, sizeof(caseExpr));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105779:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(&opCompare, 0, sizeof(opCompare));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105779:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(&opCompare, 0, sizeof(opCompare));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105961:9: warning: Access to field 'flags' results in a dereference of a null pointer (loaded from variable 'pExpr') [clang-analyzer-core.NullDereference]
    if( ExprHasProperty(pExpr,EP_Subquery) ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:36: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:161534:3: note: Control jumps to 'case 279:'  at line 162696
  switch( yyruleno ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:162698:3: note: Calling 'sqlite3Detach'
  sqlite3Detach(pParse, yymsp[0].minor.yy404);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111955:60: note: Passing null pointer value via 5th parameter 'pFilename'
  codeAttach(pParse, SQLITE_DETACH, &detach_func, pDbname, 0, 0, pDbname);
                                                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111955:3: note: Calling 'codeAttach'
  codeAttach(pParse, SQLITE_DETACH, &detach_func, pDbname, 0, 0, pDbname);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111887:7: note: Assuming field 'nErr' is 0
  if( pParse->nErr ) goto attach_end;
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111887:3: note: Taking false branch
  if( pParse->nErr ) goto attach_end;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111892:7: note: Left side of '||' is false
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) ||
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:1503:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111892:7: note: Left side of '||' is false
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) ||
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:1503:29: note: expanded from macro 'SQLITE_OK'
#define SQLITE_OK           0   /* Successful result */
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111894:24: note: Calling 'resolveAttachExpr'
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111581:7: note: Assuming 'pExpr' is null
  if( pExpr ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111581:3: note: Taking false branch
  if( pExpr ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111894:24: note: Returning from 'resolveAttachExpr'
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111891:3: note: Taking false branch
  if(
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111900:7: note: 'pAuthArg' is null
  if( pAuthArg ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111900:3: note: Taking false branch
  if( pAuthArg ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111917:27: note: Passing null pointer value via 2nd parameter 'pExpr'
  sqlite3ExprCode(pParse, pFilename, regArgs);
                          ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111917:3: note: Calling 'sqlite3ExprCode'
  sqlite3ExprCode(pParse, pFilename, regArgs);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105957:7: note: Assuming field 'pVdbe' is not equal to null
  if( pParse->pVdbe==0 ) return;
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105957:3: note: Taking false branch
  if( pParse->pVdbe==0 ) return;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105959:7: note: Assuming 'inReg' is not equal to 'target'
  if( inReg!=target ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105959:3: note: Taking true branch
  if( inReg!=target ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:105961:9: note: Access to field 'flags' results in a dereference of a null pointer (loaded from variable 'pExpr')
    if( ExprHasProperty(pExpr,EP_Subquery) ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:36: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                   ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:106105:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&compLeft, 0, sizeof(Expr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:106105:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&compLeft, 0, sizeof(Expr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:106106:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&compRight, 0, sizeof(Expr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:106106:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&compRight, 0, sizeof(Expr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:106107:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&exprAnd, 0, sizeof(Expr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:106107:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&exprAnd, 0, sizeof(Expr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:106961:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:106961:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:107038:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:107038:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:107105:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pWalker, 0, sizeof(*pWalker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:107105:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pWalker, 0, sizeof(*pWalker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:107923:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:107923:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108221:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&sNC, 0, sizeof(sNC));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108221:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&sNC, 0, sizeof(sNC));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108287:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sWalker, 0, sizeof(Walker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108287:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sWalker, 0, sizeof(Walker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108304:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sWalker, 0, sizeof(Walker));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108304:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sWalker, 0, sizeof(Walker));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108518:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, sizeof(Parse));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108518:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, sizeof(Parse));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108604:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zOut, zSql, nSql);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108604:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zOut, zSql, nSql);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108627:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(zBuf1, pBest->t.z, pBest->t.n);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108627:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(zBuf1, pBest->t.z, pBest->t.n);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108639:9: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n],
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108639:9: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
        memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n],
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108645:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&zOut[iOff], zReplace, nReplace);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108645:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&zOut[iOff], zReplace, nReplace);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108672:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108672:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108866:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sCtx, 0, sizeof(sCtx));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108866:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sCtx, 0, sizeof(sCtx));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108875:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sWalker, 0, sizeof(Walker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:108875:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sWalker, 0, sizeof(Walker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109074:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sCtx, 0, sizeof(RenameCtx));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109074:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sCtx, 0, sizeof(RenameCtx));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109076:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sWalker, 0, sizeof(Walker));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109076:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sWalker, 0, sizeof(Walker));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109093:13: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
            memset(&sNC, 0, sizeof(sNC));
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109093:13: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
            memset(&sNC, 0, sizeof(sNC));
            ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109242:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&sCtx, 0, sizeof(RenameCtx));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109242:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&sCtx, 0, sizeof(RenameCtx));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109243:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&sWalker, 0, sizeof(Walker));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109243:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&sWalker, 0, sizeof(Walker));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109349:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(&sNC, 0, sizeof(sNC));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:109349:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(&sNC, 0, sizeof(sNC));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:110007:12: warning: Value stored to 'db' during its initialization is never read [clang-analyzer-deadcode.DeadStores]
  sqlite3 *db = sqlite3_context_db_handle(context);   /* Database connection */
           ^~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:110007:12: note: Value stored to 'db' during its initialization is never read
  sqlite3 *db = sqlite3_context_db_handle(context);   /* Database connection */
           ^~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111687:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111687:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111694:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pNew, 0, sizeof(*pNew));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111694:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pNew, 0, sizeof(*pNew));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111888:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sName, 0, sizeof(NameContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111888:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sName, 0, sizeof(NameContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111892:19: warning: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc' [clang-analyzer-deadcode.DeadStores]
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) ||
                  ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111892:19: note: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc'
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) ||
                  ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111893:19: warning: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc' [clang-analyzer-deadcode.DeadStores]
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pDbname)) ||
                  ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111893:19: note: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc'
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pDbname)) ||
                  ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111894:19: warning: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc' [clang-analyzer-deadcode.DeadStores]
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))
                  ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:111894:19: note: Although the value stored to 'rc' is used in the enclosing expression, the value is never actually read from 'rc'
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))
                  ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112087:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&s, 0, sizeof(s));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112087:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&s, 0, sizeof(s));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112309:22: warning: Access to field 'nSrc' results in a dereference of a null pointer (loaded from variable 'pTabList') [clang-analyzer-core.NullDereference]
    for(iSrc=0; iSrc<pTabList->nSrc; iSrc++){
                     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99479:7: note: Assuming 'zDb' is null
  if( zDb ){
      ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99479:3: note: Taking false branch
  if( zDb ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99511:9: note: Assuming 'pSrcList' is null
    if( pSrcList ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99511:5: note: Taking false branch
    if( pSrcList ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99584:9: note: 'cnt' is equal to 0
    if( cnt==0 && zDb==0 ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99584:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99584:19: note: 'zDb' is equal to null
    if( cnt==0 && zDb==0 ){
                  ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99584:5: note: Taking true branch
    if( cnt==0 && zDb==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99587:11: note: Assuming field 'pTriggerTab' is equal to null
      if( pParse->pTriggerTab!=0 ){
          ^~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99587:7: note: Taking false branch
      if( pParse->pTriggerTab!=0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99607:11: note: Assuming the condition is false
      if( (pNC->ncFlags & NC_UUpsert)!=0 && zTab!=0 ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99607:42: note: Left side of '&&' is false
      if( (pNC->ncFlags & NC_UUpsert)!=0 && zTab!=0 ){
                                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99616:11: note: 'pTab' is null
      if( pTab ){
          ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99616:7: note: Taking false branch
      if( pTab ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99682:9: note: 'cnt' is equal to 0
    if( cnt==0
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99682:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99683:9: note: 'cntTab' is not equal to 1
     && cntTab==1
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99684:6: note: Left side of '&&' is false
     && pMatch
     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99712:9: note: 'cnt' is equal to 0
    if( cnt==0
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99712:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99713:9: note: Assuming the condition is true
     && (pNC->ncFlags & NC_UEList)!=0
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99712:9: note: Left side of '&&' is true
    if( cnt==0
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99714:9: note: Assuming 'zTab' is equal to null
     && zTab==0
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99712:5: note: Taking true branch
    if( cnt==0
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99718:16: note: Assuming 'j' is < field 'nExpr'
      for(j=0; j<pEList->nExpr; j++){
               ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99718:7: note: Loop condition is true.  Entering loop body
      for(j=0; j<pEList->nExpr; j++){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99720:13: note: Assuming field 'eEName' is equal to ENAME_NAME
        if( pEList->a[j].eEName==ENAME_NAME
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99720:13: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99721:13: note: Assuming the condition is true
         && sqlite3_stricmp(zAs, zCol)==0
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99720:9: note: Taking true branch
        if( pEList->a[j].eEName==ENAME_NAME
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99728:15: note: Assuming the condition is false
          if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99728:45: note: Left side of '&&' is false
          if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){
                                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99732:15: note: Assuming the condition is false
          if( ExprHasProperty(pOrig, EP_Win)
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18390:35: note: expanded from macro 'ExprHasProperty'
#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)
                                  ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99733:12: note: Left side of '&&' is false
           && ((pNC->ncFlags&NC_AllowWin)==0 || pNC!=pTopNC )
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99738:11: note: Taking false branch
          if( sqlite3ExprVectorSize(pOrig)!=1 ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99742:11: note: Calling 'resolveAlias'
          resolveAlias(pParse, pEList, j, pExpr, nSubquery);
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99293:10: note: Calling 'sqlite3ExprDup'
  pDup = sqlite3ExprDup(db, pOrig, 0);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102716:10: note: 'p' is non-null
  return p ? exprDup(db, p, flags, 0) : 0;
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102716:10: note: '?' condition is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102716:14: note: Value assigned to field 'xAuth', which participates in a condition later
  return p ? exprDup(db, p, flags, 0) : 0;
             ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99293:10: note: Returning from 'sqlite3ExprDup'
  pDup = sqlite3ExprDup(db, pOrig, 0);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99294:7: note: Assuming field 'mallocFailed' is not equal to 0
  if( db->mallocFailed ){
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99294:3: note: Taking true branch
  if( db->mallocFailed ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99295:5: note: Calling 'sqlite3ExprDelete'
    sqlite3ExprDelete(db, pDup);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102385:7: note: Assuming 'p' is null
  if( p ) sqlite3ExprDeleteNN(db, p);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102385:3: note: Taking false branch
  if( p ) sqlite3ExprDeleteNN(db, p);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:102386:1: note: Returning without writing to '->xAuth', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99295:5: note: Returning from 'sqlite3ExprDelete'
    sqlite3ExprDelete(db, pDup);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99742:11: note: Returning from 'resolveAlias'
          resolveAlias(pParse, pEList, j, pExpr, nSubquery);
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99746:15: note: Assuming field 'eParseMode' is < 2
          if( IN_RENAME_OBJECT ){
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19136:29: note: expanded from macro 'IN_RENAME_OBJECT'
  #define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99746:11: note: Taking false branch
          if( IN_RENAME_OBJECT ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99749:11: note: Control jumps to line 99853
          goto lookupname_end;
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99853:7: note: 'cnt' is equal to 1
  if( cnt==1 ){
      ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99853:3: note: Taking true branch
  if( cnt==1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99856:9: note: Assuming field 'xAuth' is non-null
    if( pParse->db->xAuth
        ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99856:9: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99857:10: note: Assuming field 'op' is equal to TK_COLUMN
     && (pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER)
         ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99857:31: note: Left side of '||' is true
     && (pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER)
                              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99859:47: note: Passing null pointer value via 4th parameter 'pTabList'
      sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
                                              ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:99859:7: note: Calling 'sqlite3AuthRead'
      sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112299:7: note: Assuming 'iDb' is >= 0
  if( iDb<0 ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112299:3: note: Taking false branch
  if( iDb<0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112305:14: note: Field 'op' is not equal to TK_TRIGGER
  if( pExpr->op==TK_TRIGGER ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112305:3: note: Taking false branch
  if( pExpr->op==TK_TRIGGER ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112309:22: note: Access to field 'nSrc' results in a dereference of a null pointer (loaded from variable 'pTabList')
    for(iSrc=0; iSrc<pTabList->nSrc; iSrc++){
                     ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112732:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112732:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112733:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112733:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112737:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(PARSE_TAIL(pParse), saveBuf, PARSE_TAIL_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112737:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(PARSE_TAIL(pParse), saveBuf, PARSE_TAIL_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:113020:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:113020:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:113805:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(z, pName->z, pName->n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:113805:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(z, pName->z, pName->n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:113826:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pCol, 0, sizeof(p->aCol[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:113826:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pCol, 0, sizeof(p->aCol[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:113843:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zType, pType->z, pType->n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:113843:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zType, pType->z, pType->n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114012:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&x, 0, sizeof(x));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114012:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&x, 0, sizeof(x));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114417:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&zStmt[k], zType, len);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114417:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(&zStmt[k], zType, len);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114437:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114437:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114440:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(zExtra, pIdx->aiRowLogEst, sizeof(LogEst)*(pIdx->nKeyCol+1));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114440:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(zExtra, pIdx->aiRowLogEst, sizeof(LogEst)*(pIdx->nKeyCol+1));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114443:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114443:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114446:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114446:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115117:9: warning: Access to field 'z' results in a dereference of a null pointer (loaded from variable 'pCons') [clang-analyzer-core.NullDereference]
    if( pCons->z==0 ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:161534:3: note: Control jumps to 'case 80:'  at line 161813
  switch( yyruleno ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:161815:3: note: Calling 'sqlite3CreateView'
  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy70, yymsp[0].minor.yy81, yymsp[-7].minor.yy376, yymsp[-5].minor.yy376);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115148:7: note: Assuming field 'nVar' is <= 0
  if( pParse->nVar>0 ){
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115148:3: note: Taking false branch
  if( pParse->nVar>0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115154:7: note: Assuming 'p' is not equal to null
  if( p==0 || pParse->nErr ) goto create_view_fail;
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115154:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115154:15: note: Assuming field 'nErr' is 0
  if( p==0 || pParse->nErr ) goto create_view_fail;
              ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115154:3: note: Taking false branch
  if( p==0 || pParse->nErr ) goto create_view_fail;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115168:7: note: Assuming the condition is false
  if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115168:3: note: Taking false branch
  if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115176:7: note: Assuming field 'eParseMode' is < 2
  if( IN_RENAME_OBJECT ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19136:29: note: expanded from macro 'IN_RENAME_OBJECT'
  #define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115176:3: note: Taking false branch
  if( IN_RENAME_OBJECT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115183:7: note: Assuming field 'mallocFailed' is 0
  if( db->mallocFailed ) goto create_view_fail;
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115183:3: note: Taking false branch
  if( db->mallocFailed ) goto create_view_fail;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115190:7: note: Assuming the condition is false
  if( sEnd.z[0]!=';' ){
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115190:3: note: Taking false branch
  if( sEnd.z[0]!=';' ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115197:3: note: Loop condition is false. Execution continues on line 115198
  while( sqlite3Isspace(z[n-1]) ){ n--; }
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115202:27: note: Passing null pointer value via 2nd parameter 'pCons'
  sqlite3EndTable(pParse, 0, &sEnd, 0, 0);
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115202:3: note: Calling 'sqlite3EndTable'
  sqlite3EndTable(pParse, 0, &sEnd, 0, 0);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114842:7: note: 'pEnd' is not equal to null
  if( pEnd==0 && pSelect==0 ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114842:15: note: Left side of '&&' is false
  if( pEnd==0 && pSelect==0 ){
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114846:7: note: Assuming 'p' is not equal to null
  if( p==0 ) return;
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114846:3: note: Taking false branch
  if( p==0 ) return;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114848:7: note: 'pSelect' is equal to null
  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114848:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114848:21: note: Calling 'sqlite3ShadowTableName'
  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114773:7: note: Assuming 'zTail' is not equal to null
  if( zTail==0 ) return 0;
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114773:3: note: Taking false branch
  if( zTail==0 ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114775:10: note: Value assigned to field 'busy', which participates in a condition later
  pTab = sqlite3FindTable(db, zName, 0);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114777:7: note: Assuming 'pTab' is not equal to null
  if( pTab==0 ) return 0;
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114777:3: note: Taking false branch
  if( pTab==0 ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114778:7: note: Assuming field 'nModuleArg' is not equal to 0
  if( !IsVirtual(pTab) ) return 0;
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114778:3: note: Taking false branch
  if( !IsVirtual(pTab) ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114779:10: note: Calling 'sqlite3IsShadowTableOf'
  return sqlite3IsShadowTableOf(db, pTab, zName);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114749:8: note: Field 'nModuleArg' is not equal to 0
  if( !IsVirtual(pTab) ) return 0;
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17837:35: note: expanded from macro 'IsVirtual'
#  define IsVirtual(X)      ((X)->nModuleArg)
                                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114749:3: note: Taking false branch
  if( !IsVirtual(pTab) ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114751:7: note: Assuming the condition is false
  if( sqlite3_strnicmp(zName, pTab->zName, nName)!=0 ) return 0;
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114751:3: note: Taking false branch
  if( sqlite3_strnicmp(zName, pTab->zName, nName)!=0 ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114752:7: note: Assuming the condition is false
  if( zName[nName]!='_' ) return 0;
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114752:3: note: Taking false branch
  if( zName[nName]!='_' ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114754:7: note: Assuming 'pMod' is not equal to null
  if( pMod==0 ) return 0;
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114754:3: note: Taking false branch
  if( pMod==0 ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114755:7: note: Assuming field 'iVersion' is >= 3
  if( pMod->pModule->iVersion<3 ) return 0;
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114755:3: note: Taking false branch
  if( pMod->pModule->iVersion<3 ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114756:7: note: Assuming field 'xShadowName' is not equal to null
  if( pMod->pModule->xShadowName==0 ) return 0;
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114756:3: note: Taking false branch
  if( pMod->pModule->xShadowName==0 ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114757:3: note: Returning without writing to 'db->init.busy', which participates in a condition later
  return pMod->pModule->xShadowName(zName+nName+1);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114779:10: note: Returning from 'sqlite3IsShadowTableOf'
  return sqlite3IsShadowTableOf(db, pTab, zName);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114848:21: note: Returning from 'sqlite3ShadowTableName'
  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114848:21: note: Assuming the condition is false
  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114848:3: note: Taking false branch
  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114861:7: note: Assuming field 'busy' is 0
  if( db->init.busy ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114861:3: note: Taking false branch
  if( db->init.busy ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114876:3: note: Taking false branch
  if( tabOpts & TF_WithoutRowid ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114894:7: note: Assuming field 'pCheck' is null
  if( p->pCheck ){
      ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114894:3: note: Taking false branch
  if( p->pCheck ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114907:7: note: Assuming the condition is false
  if( p->tabFlags & TF_HasGenerated ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114907:3: note: Taking false branch
  if( p->tabFlags & TF_HasGenerated ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114939:3: note: Calling 'estimateTableWidth'
  estimateTableWidth(p);
  ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114460:41: note: Assuming 'i' is <= 0
  for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){
                                        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114460:3: note: Loop condition is false. Execution continues on line 114463
  for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114463:7: note: Assuming field 'iPKey' is >= 0
  if( pTab->iPKey<0 ) wTable++;
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114463:3: note: Taking false branch
  if( pTab->iPKey<0 ) wTable++;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114465:1: note: Returning without writing to 'pTab->pSelect', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114939:3: note: Returning from 'estimateTableWidth'
  estimateTableWidth(p);
  ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114940:3: note: Loop condition is false. Execution continues on line 114950
  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114950:7: note: Assuming field 'busy' is not equal to 0
  if( !db->init.busy ){
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:114950:3: note: Taking false branch
  if( !db->init.busy ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115088:16: note: Field 'busy' is not equal to 0
  if( db->init.busy ){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115088:3: note: Taking true branch
  if( db->init.busy ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115094:9: note: Assuming 'pOld' is null
    if( pOld ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115094:5: note: Taking false branch
    if( pOld ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115107:9: note: Assuming the condition is false
    if( strcmp(p->zName, "sqlite_sequence")==0 ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115107:5: note: Taking false branch
    if( strcmp(p->zName, "sqlite_sequence")==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115115:8: note: 'pSelect' is null
  if( !pSelect && !p->pSelect ){
       ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115115:7: note: Left side of '&&' is true
  if( !pSelect && !p->pSelect ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115115:19: note: Assuming field 'pSelect' is null
  if( !pSelect && !p->pSelect ){
                  ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115115:3: note: Taking true branch
  if( !pSelect && !p->pSelect ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115117:9: note: Access to field 'z' results in a dereference of a null pointer (loaded from variable 'pCons')
    if( pCons->z==0 ){
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115797:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(z, pTo->z, pTo->n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115797:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(z, pTo->z, pTo->n);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115831:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(z, pToCol->a[i].zEName, n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:115831:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(z, pToCol->a[i].zEName, n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116297:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pIndex->zName, zName, nName+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116297:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pIndex->zName, zName, nName+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116376:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zExtra, zColl, nColl);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116376:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zExtra, zColl, nColl);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116565:46: warning: Access to field 'z' results in a dereference of a null pointer (loaded from variable 'pName') [clang-analyzer-core.NullDereference]
        int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;
                                             ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116084:3: note: 'pName' initialized to a null pointer value
  Token *pName = 0;    /* Unqualified name of the index to create */
  ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116091:7: note: Assuming field 'mallocFailed' is 0
  if( db->mallocFailed || pParse->nErr>0 ){
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116091:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116091:27: note: Assuming field 'nErr' is <= 0
  if( db->mallocFailed || pParse->nErr>0 ){
                          ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116091:3: note: Taking false branch
  if( db->mallocFailed || pParse->nErr>0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116094:7: note: Assuming field 'eParseMode' is not equal to 1
  if( IN_DECLARE_VTAB && idxType!=SQLITE_IDXTYPE_PRIMARYKEY ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19130:28: note: expanded from macro 'IN_DECLARE_VTAB'
  #define IN_DECLARE_VTAB (pParse->eParseMode==PARSE_MODE_DECLARE_VTAB)
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116094:23: note: Left side of '&&' is false
  if( IN_DECLARE_VTAB && idxType!=SQLITE_IDXTYPE_PRIMARYKEY ){
                      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116097:18: note: Calling 'sqlite3ReadSchema'
  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){
                 ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131516:7: note: Assuming field 'busy' is not equal to 0
  if( !db->init.busy ){
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131516:3: note: Taking false branch
  if( !db->init.busy ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131525:3: note: Returning without writing to 'pParse->pNewTable', which participates in a condition later
  return rc;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131525:3: note: Returning without writing to 'pParse->nErr', which participates in a condition later
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116097:18: note: Returning from 'sqlite3ReadSchema'
  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){
                 ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116097:3: note: Taking false branch
  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116100:7: note: Assuming the condition is false
  if( sqlite3HasExplicitNulls(pParse, pList) ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116100:3: note: Taking false branch
  if( sqlite3HasExplicitNulls(pParse, pList) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116107:7: note: Assuming 'pTblName' is equal to null
  if( pTblName!=0 ){
      ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116107:3: note: Taking false branch
  if( pTblName!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116151:9: note: Assuming 'pTab' is non-null
    if( !pTab ) goto exit_create_index;
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116151:5: note: Taking false branch
    if( !pTab ) goto exit_create_index;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116158:7: note: Assuming the condition is false
  if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19755:25: note: expanded from macro 'sqlite3StrNICmp'
#define sqlite3StrNICmp sqlite3_strnicmp
                        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116159:8: note: Left side of '&&' is false
       && db->init.busy==0
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116169:7: note: Assuming field 'pSelect' is null
  if( pTab->pSelect ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116169:3: note: Taking false branch
  if( pTab->pSelect ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116175:7: note: Assuming field 'nModuleArg' is 0
  if( IsVirtual(pTab) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17837:29: note: expanded from macro 'IsVirtual'
#  define IsVirtual(X)      ((X)->nModuleArg)
                            ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116175:3: note: Taking false branch
  if( IsVirtual(pTab) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116194:7: note: 'pName' is null
  if( pName ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116194:3: note: Taking false branch
  if( pName ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116222:34: note: Assuming pointer value is null
    for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}
                                 ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116222:5: note: Loop condition is false. Execution continues on line 116223
    for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116224:9: note: Assuming 'zName' is not equal to null
    if( zName==0 ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116224:5: note: Taking false branch
    if( zName==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116233:9: note: Assuming field 'eParseMode' is equal to 0
    if( IN_SPECIAL_PARSE ) zName[7]++;
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19142:29: note: expanded from macro 'IN_SPECIAL_PARSE'
  #define IN_SPECIAL_PARSE (pParse->eParseMode!=PARSE_MODE_NORMAL)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116233:5: note: Taking false branch
    if( IN_SPECIAL_PARSE ) zName[7]++;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116239:8: note: Field 'eParseMode' is < 2
  if( !IN_RENAME_OBJECT ){
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19136:37: note: expanded from macro 'IN_RENAME_OBJECT'
  #define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME)
                                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116239:3: note: Taking true branch
  if( !IN_RENAME_OBJECT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116241:49: note: Left side of '&&' is true
    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){
                                                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14813:6: note: expanded from macro 'SCHEMA_TABLE'
    ((!OMIT_TEMPDB)&&(x==1)?DFLT_TEMP_SCHEMA_TABLE:DFLT_SCHEMA_TABLE)
     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116241:62: note: Assuming 'iDb' is not equal to 1
    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){
                                                             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14813:23: note: expanded from macro 'SCHEMA_TABLE'
    ((!OMIT_TEMPDB)&&(x==1)?DFLT_TEMP_SCHEMA_TABLE:DFLT_SCHEMA_TABLE)
                      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116241:49: note: '?' condition is false
    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){
                                                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14813:6: note: expanded from macro 'SCHEMA_TABLE'
    ((!OMIT_TEMPDB)&&(x==1)?DFLT_TEMP_SCHEMA_TABLE:DFLT_SCHEMA_TABLE)
     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116241:9: note: Calling 'sqlite3AuthCheck'
    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:7: note: Assuming field 'xAuth' is not equal to null
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:23: note: Assuming field 'busy' is 0
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
                      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:7: note: Left side of '||' is false
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:40: note: Field 'eParseMode' is equal to 0
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
                                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19142:37: note: expanded from macro 'IN_SPECIAL_PARSE'
  #define IN_SPECIAL_PARSE (pParse->eParseMode!=PARSE_MODE_NORMAL)
                                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:3: note: Taking false branch
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112374:7: note: Assuming 'rc' is not equal to SQLITE_DENY
  if( rc==SQLITE_DENY ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112374:3: note: Taking false branch
  if( rc==SQLITE_DENY ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112377:13: note: Assuming 'rc' is equal to SQLITE_OK
  }else if( rc!=SQLITE_OK && rc!=SQLITE_IGNORE ){
            ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112377:27: note: Left side of '&&' is false
  }else if( rc!=SQLITE_OK && rc!=SQLITE_IGNORE ){
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112381:3: note: Returning without writing to 'pParse->nErr', which participates in a condition later
  return rc;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116241:9: note: Returning from 'sqlite3AuthCheck'
    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116241:5: note: Taking false branch
    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116245:9: note: Left side of '&&' is true
    if( !OMIT_TEMPDB && iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX;
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116245:25: note: 'iDb' is not equal to 1
    if( !OMIT_TEMPDB && iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX;
                        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116245:5: note: Taking false branch
    if( !OMIT_TEMPDB && iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116246:9: note: Calling 'sqlite3AuthCheck'
    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:11: note: Field 'xAuth' is not equal to null
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:7: note: Left side of '||' is false
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:32: note: Field 'busy' is 0
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
                               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:7: note: Left side of '||' is false
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:40: note: Field 'eParseMode' is equal to 0
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
                                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19142:37: note: expanded from macro 'IN_SPECIAL_PARSE'
  #define IN_SPECIAL_PARSE (pParse->eParseMode!=PARSE_MODE_NORMAL)
                                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112354:3: note: Taking false branch
  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112374:7: note: Assuming 'rc' is not equal to SQLITE_DENY
  if( rc==SQLITE_DENY ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112374:3: note: Taking false branch
  if( rc==SQLITE_DENY ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112377:13: note: Assuming 'rc' is equal to SQLITE_OK
  }else if( rc!=SQLITE_OK && rc!=SQLITE_IGNORE ){
            ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112377:27: note: Left side of '&&' is false
  }else if( rc!=SQLITE_OK && rc!=SQLITE_IGNORE ){
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:112381:3: note: Returning without writing to 'pParse->nErr', which participates in a condition later
  return rc;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116246:9: note: Returning from 'sqlite3AuthCheck'
    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116246:5: note: Taking false branch
    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116256:7: note: Assuming 'pList' is not equal to null
  if( pList==0 ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116256:3: note: Taking false branch
  if( pList==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116267:5: note: Calling 'sqlite3ExprListCheckLength'
    sqlite3ExprListCheckLength(pParse, pList, "index");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103148:7: note: 'pEList' is non-null
  if( pEList && pEList->nExpr>mx ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103148:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103148:17: note: Assuming 'mx' is >= field 'nExpr'
  if( pEList && pEList->nExpr>mx ){
                ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103148:3: note: Taking false branch
  if( pEList && pEList->nExpr>mx ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:103151:1: note: Returning without writing to 'pParse->nErr', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116267:5: note: Returning from 'sqlite3ExprListCheckLength'
    sqlite3ExprListCheckLength(pParse, pList, "index");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116268:9: note: Assuming field 'nErr' is 0
    if( pParse->nErr ) goto exit_create_index;
        ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116268:5: note: Taking false branch
    if( pParse->nErr ) goto exit_create_index;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116274:12: note: Assuming 'i' is >= field 'nExpr'
  for(i=0; i<pList->nExpr; i++){
           ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116274:3: note: Loop condition is false. Execution continues on line 116285
  for(i=0; i<pList->nExpr; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116286:15: note: 'pPk' is null
  nExtraCol = pPk ? pPk->nKeyCol : 1;
              ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116286:15: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116288:12: note: Calling 'sqlite3AllocateIndexObject'
  pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol,
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116014:7: note: Calling 'sqlite3DbMallocZero'
  p = sqlite3DbMallocZero(db, nByte + nExtra);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28329:7: note: Calling 'sqlite3DbMallocRaw'
  p = sqlite3DbMallocRaw(db, n);
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28372:7: note: 'db' is non-null
  if( db ) return sqlite3DbMallocRawNN(db, n);
      ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28372:3: note: Taking true branch
  if( db ) return sqlite3DbMallocRawNN(db, n);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28372:19: note: Value assigned to field 'mallocFailed', which participates in a condition later
  if( db ) return sqlite3DbMallocRawNN(db, n);
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28372:19: note: Value assigned to field 'busy', which participates in a condition later
  if( db ) return sqlite3DbMallocRawNN(db, n);
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28329:7: note: Returning from 'sqlite3DbMallocRaw'
  p = sqlite3DbMallocRaw(db, n);
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28330:7: note: Assuming 'p' is non-null
  if( p ) memset(p, 0, (size_t)n);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28330:3: note: Taking true branch
  if( p ) memset(p, 0, (size_t)n);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116014:7: note: Returning from 'sqlite3DbMallocZero'
  p = sqlite3DbMallocZero(db, nByte + nExtra);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116015:7: note: 'p' is non-null
  if( p ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116015:3: note: Taking true branch
  if( p ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116288:12: note: Returning from 'sqlite3AllocateIndexObject'
  pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol,
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116290:7: note: Assuming field 'mallocFailed' is 0
  if( db->mallocFailed ){
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116290:3: note: Taking false branch
  if( db->mallocFailed ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116300:25: note: Assuming 'onError' is equal to OE_None
  pIndex->uniqNotNull = onError!=OE_None;
                        ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116304:7: note: Assuming 'pPIWhere' is null
  if( pPIWhere ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116304:3: note: Taking false branch
  if( pPIWhere ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116313:7: note: Assuming field 'file_format' is < 4
  if( pDb->pSchema->file_format>=4 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116313:3: note: Taking false branch
  if( pDb->pSchema->file_format>=4 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116329:7: note: Field 'eParseMode' is < 2
  if( IN_RENAME_OBJECT ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19136:37: note: expanded from macro 'IN_RENAME_OBJECT'
  #define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME)
                                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116329:3: note: Taking false branch
  if( IN_RENAME_OBJECT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116333:12: note: 'i' is >= field 'nKeyCol'
  for(i=0; i<pIndex->nKeyCol; i++, pListItem++){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116333:3: note: Loop condition is false. Execution continues on line 116396
  for(i=0; i<pIndex->nKeyCol; i++, pListItem++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116396:7: note: 'pPk' is null
  if( pPk ){
      ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116396:3: note: Taking false branch
  if( pPk ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116416:15: note: Field 'pNewTable' is not equal to null
  if( pParse->pNewTable==0 ) estimateIndexWidth(pIndex);
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116416:3: note: Taking false branch
  if( pParse->pNewTable==0 ) estimateIndexWidth(pIndex);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116423:7: note: 'pTblName' is equal to null
  if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){
      ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116423:19: note: Left side of '&&' is false
  if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116433:7: note: 'pTab' is equal to field 'pNewTable'
  if( pTab==pParse->pNewTable ){
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116433:3: note: Taking true branch
  if( pTab==pParse->pNewTable ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116456:5: note: Loop condition is false. Execution continues on line 116500
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116500:8: note: Field 'eParseMode' is < 2
  if( !IN_RENAME_OBJECT ){
       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:19136:37: note: expanded from macro 'IN_RENAME_OBJECT'
  #define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME)
                                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116500:3: note: Taking true branch
  if( !IN_RENAME_OBJECT ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116506:9: note: Assuming field 'busy' is 0
    if( db->init.busy ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116506:5: note: Taking false branch
    if( db->init.busy ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116541:14: note: Assuming the condition is true
    else if( HasRowid(pTab) || pTblName!=0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116541:29: note: Left side of '||' is true
    else if( HasRowid(pTab) || pTblName!=0 ){
                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116547:11: note: 'v' is not equal to null
      if( v==0 ) goto exit_create_index;
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116547:7: note: Taking false branch
      if( v==0 ) goto exit_create_index;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116564:11: note: Assuming 'pStart' is non-null
      if( pStart ){
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116564:7: note: Taking true branch
      if( pStart ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116565:46: note: Access to field 'z' results in a dereference of a null pointer (loaded from variable 'pName')
        int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;
                                             ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116621:13: warning: Value stored to 'ppFrom' during its initialization is never read [clang-analyzer-deadcode.DeadStores]
    Index **ppFrom = &pTab->pIndex;
            ^~~~~~   ~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116621:13: note: Value stored to 'ppFrom' during its initialization is never read
    Index **ppFrom = &pTab->pIndex;
            ^~~~~~   ~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116700:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116700:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116814:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&z[n * szEntry], 0, szEntry);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116814:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&z[n * szEntry], 0, szEntry);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116952:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:116952:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117014:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&pList->a[0], 0, sizeof(pList->a[0]));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117014:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&pList->a[0], 0, sizeof(pList->a[0]));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117178:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&p1->a[1], p2->a, p2->nSrc*sizeof(SrcItem));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117178:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&p1->a[1], p2->a, p2->nSrc*sizeof(SrcItem));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117861:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pColl, pColl2, sizeof(CollSeq));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117861:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pColl, pColl2, sizeof(CollSeq));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117927:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pColl[0].zName, zName, nName);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:117927:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pColl[0].zName, zName, nName);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118262:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy((char*)&pBest[1], zName, nName+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118262:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy((char*)&pBest[1], zName, nName+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118623:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sContext, 0, sizeof(sContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118623:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sContext, 0, sizeof(sContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118723:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118723:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118846:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(aToOpen, 1, nIdx+1);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118846:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(aToOpen, 1, nIdx+1);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:120208:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&backupInfo, pInfo, sizeof(backupInfo));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:120208:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&backupInfo, pInfo, sizeof(backupInfo));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:120609:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(&zOut[j], zRep, nRep);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:120609:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(&zOut[j], zRep, nRep);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:120615:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&zOut[j], &zStr[i], nStr-i);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:120615:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&zOut[j], &zStr[i], nStr-i);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:121089:7: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memmove(pAccum->zText, &pAccum->zText[n], pAccum->nChar);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:121089:7: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
      memmove(pAccum->zText, &pAccum->zText[n], pAccum->nChar);
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:121203:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(aWc, pDef->pUserData, 3);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:121203:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(aWc, pDef->pUserData, 3);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122231:18: warning: Access to field 'nKeyCol' results in a dereference of a null pointer (loaded from variable 'pIdx') [clang-analyzer-core.NullDereference]
      for(i=0; i<pIdx->nKeyCol; i++){
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124675:14: note: Assuming 'regOldData' is equal to 0
  isUpdate = regOldData!=0;
             ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124686:7: note: Assuming the condition is false
  if( HasRowid(pTab) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124686:3: note: Taking false branch
  if( HasRowid(pTab) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124700:7: note: Assuming the condition is false
  if( pTab->tabFlags & TF_HasNotNull ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124700:3: note: Taking false branch
  if( pTab->tabFlags & TF_HasNotNull ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124801:7: note: Assuming field 'pCheck' is null
  if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124801:20: note: Left side of '&&' is false
  if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124875:7: note: Assuming 'pUpsert' is null
  if( pUpsert ){
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124875:3: note: Taking false branch
  if( pUpsert ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124951:7: note: Assuming the condition is false
  if( (db->flags & (SQLITE_RecTriggers|SQLITE_ForeignKeys))==0 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124951:3: note: Taking false branch
  if( (db->flags & (SQLITE_RecTriggers|SQLITE_ForeignKeys))==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124957:9: note: Assuming the condition is false
    if( db->flags&SQLITE_RecTriggers ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124957:5: note: Taking false branch
    if( db->flags&SQLITE_RecTriggers ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124962:20: note: Calling 'sqlite3FkRequired'
      regTrigCnt = sqlite3FkRequired(pParse, pTab, 0, 0);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122734:7: note: Assuming the condition is false
  if( pParse->db->flags&SQLITE_ForeignKeys ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122734:3: note: Taking false branch
  if( pParse->db->flags&SQLITE_ForeignKeys ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122762:10: note: 'bHaveFK' is 0
  return bHaveFK ? eRet : 0;
         ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122762:10: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122762:3: note: Returning without writing to 'pTab->pFKey', which participates in a condition later
  return bHaveFK ? eRet : 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124962:20: note: Returning from 'sqlite3FkRequired'
      regTrigCnt = sqlite3FkRequired(pParse, pTab, 0, 0);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124964:9: note: 'regTrigCnt' is 0
    if( regTrigCnt ){
        ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124964:5: note: Taking false branch
    if( regTrigCnt ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124978:7: note: Assuming 'pkChng' is 0
  if( pkChng && pPk==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124978:14: note: Left side of '&&' is false
  if( pkChng && pPk==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125125:3: note: Loop condition is true.  Entering loop body
  for(pIdx = indexIteratorFirst(&sIdxIter, &ix);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125135:9: note: Assuming the condition is false
    if( aRegIdx[ix]==0 ) continue;  /* Skip indices that do not change */
        ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125135:5: note: Taking false branch
    if( aRegIdx[ix]==0 ) continue;  /* Skip indices that do not change */
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125136:9: note: 'pUpsert' is null
    if( pUpsert ){
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125136:5: note: Taking false branch
    if( pUpsert ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125143:9: note: 'bAffinityDone' is equal to 0
    if( bAffinityDone==0 ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125143:5: note: Taking true branch
    if( bAffinityDone==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125144:7: note: Calling 'sqlite3TableAffinity'
      sqlite3TableAffinity(v, pTab, regNewData+1);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123193:7: note: Assuming 'zColAff' is not equal to null
  if( zColAff==0 ){
      ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123193:3: note: Taking false branch
  if( zColAff==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123214:7: note: Assuming 'i' is 0
  if( i ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123214:3: note: Taking false branch
  if( i ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123221:1: note: Returning without writing to 'pTab->pFKey', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125144:7: note: Returning from 'sqlite3TableAffinity'
      sqlite3TableAffinity(v, pTab, regNewData+1);
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125152:9: note: Assuming field 'pPartIdxWhere' is null
    if( pIdx->pPartIdxWhere ){
        ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125152:5: note: Taking false branch
    if( pIdx->pPartIdxWhere ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125164:14: note: Assuming 'i' is >= field 'nColumn'
    for(i=0; i<pIdx->nColumn; i++){
             ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125164:5: note: Loop condition is false. Execution continues on line 125183
    for(i=0; i<pIdx->nColumn; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125196:9: note: 'isUpdate' is 0
    if( isUpdate && pPk==pIdx && pkChng==0 ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125196:18: note: Left side of '&&' is false
    if( isUpdate && pPk==pIdx && pkChng==0 ){
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125203:9: note: Assuming 'onError' is not equal to OE_None
    if( onError==OE_None ){
        ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125203:5: note: Taking false branch
    if( onError==OE_None ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125207:9: note: Assuming 'overrideError' is equal to OE_Default
    if( overrideError!=OE_Default ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125207:5: note: Taking false branch
    if( overrideError!=OE_Default ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125209:15: note: Assuming 'onError' is not equal to OE_Default
    }else if( onError==OE_Default ){
              ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125209:11: note: Taking false branch
    }else if( onError==OE_Default ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125214:9: note: 'pUpsertClause' is null
    if( pUpsertClause ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125214:5: note: Taking false branch
    if( pUpsertClause ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125233:10: note: 'ix' is equal to 0
    if( (ix==0 && pIdx->pNext==0)                   /* Condition 3 */
         ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125233:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125233:19: note: Assuming field 'pNext' is not equal to null
    if( (ix==0 && pIdx->pNext==0)                   /* Condition 3 */
                  ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125234:6: note: Left side of '&&' is false
     && pPk==pIdx                                   /* Condition 2 */
     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125253:12: note: Assuming 'pIdx' is not equal to 'pPk'
    regR = pIdx==pPk ? regIdx : sqlite3GetTempRange(pParse, nPkField);
           ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125253:12: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125254:9: note: 'isUpdate' is 0
    if( isUpdate || onError==OE_Replace ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125254:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125254:21: note: Assuming 'onError' is not equal to OE_Replace
    if( isUpdate || onError==OE_Replace ){
                    ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125254:5: note: Taking false branch
    if( isUpdate || onError==OE_Replace ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125312:5: note: Control jumps to the 'default' case at line 125333
    switch( onError ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125340:13: note: 'regTrigCnt' is 0
        if( regTrigCnt ){
            ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125340:9: note: Taking false branch
        if( regTrigCnt ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125344:13: note: 'pTrigger' is null
        if( pTrigger && isUpdate ){
            ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125344:22: note: Left side of '&&' is false
        if( pTrigger && isUpdate ){
                     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125349:14: note: 'pIdx' is not equal to 'pPk'
            (pIdx==pPk ? ONEPASS_SINGLE : ONEPASS_OFF), iThisCur);
             ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125349:14: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125347:9: note: Calling 'sqlite3GenerateRowDelete'
        sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119055:12: note: Assuming the condition is true
  opSeek = HasRowid(pTab) ? OP_NotExists : OP_NotFound;
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119055:12: note: '?' condition is true
  opSeek = HasRowid(pTab) ? OP_NotExists : OP_NotFound;
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:25: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119056:7: note: 'eMode' is equal to ONEPASS_OFF
  if( eMode==ONEPASS_OFF ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119056:3: note: Taking true branch
  if( eMode==ONEPASS_OFF ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119064:7: note: Assuming the condition is true
  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119064:45: note: Left side of '||' is true
  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){
                                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119071:12: note: Calling 'sqlite3TriggerColmask'
    mask = sqlite3TriggerColmask(
           ^~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141065:18: note: 'pChanges' is null
  const int op = pChanges ? TK_UPDATE : TK_DELETE;
                 ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141065:18: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141070:3: note: Loop condition is false. Execution continues on line 141087
  for(p=pTrigger; p; p=p->pNext){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141087:3: note: Returning without writing to '->pFKey', which participates in a condition later
  return mask;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119071:12: note: Returning from 'sqlite3TriggerColmask'
    mask = sqlite3TriggerColmask(
           ^~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119074:13: note: Calling 'sqlite3FkOldmask'
    mask |= sqlite3FkOldmask(pParse, pTab);
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122681:7: note: Assuming the condition is true
  if( pParse->db->flags&SQLITE_ForeignKeys ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122681:3: note: Taking true branch
  if( pParse->db->flags&SQLITE_ForeignKeys ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122684:24: note: Assuming pointer value is null
    for(p=pTab->pFKey; p; p=p->pNextFrom){
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122684:5: note: Loop condition is false. Execution continues on line 122687
    for(p=pTab->pFKey; p; p=p->pNextFrom){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122687:11: note: Calling 'sqlite3FkReferences'
    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
          ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122283:3: note: Returning without writing to 'pTab->pFKey', which participates in a condition later
  return (FKey *)sqlite3HashFind(&pTab->pSchema->fkeyHash, pTab->zName);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122687:11: note: Returning from 'sqlite3FkReferences'
    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
          ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122687:5: note: Loop condition is false. Execution continues on line 122698
    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122698:3: note: Returning without writing to '->pFKey', which participates in a condition later
  return mask;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119074:13: note: Returning from 'sqlite3FkOldmask'
    mask |= sqlite3FkOldmask(pParse, pTab);
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119081:17: note: Assuming 'iCol' is >= field 'nCol'
    for(iCol=0; iCol<pTab->nCol; iCol++){
                ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119081:5: note: Loop condition is false. Execution continues on line 119091
    for(iCol=0; iCol<pTab->nCol; iCol++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119092:5: note: Calling 'sqlite3CodeRowTrigger'
    sqlite3CodeRowTrigger(pParse, pTrigger,
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141003:3: note: Loop condition is false. Execution continues on line 141003
  for(p=pTrigger; p; p=p->pNext){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141029:1: note: Returning without writing to '->pFKey', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119092:5: note: Returning from 'sqlite3CodeRowTrigger'
    sqlite3CodeRowTrigger(pParse, pTrigger,
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119104:5: note: Taking false branch
    if( addrStart<sqlite3VdbeCurrentAddr(v) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119115:5: note: Calling 'sqlite3FkCheck'
    sqlite3FkCheck(pParse, pTab, iOld, 0, 0, 0);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122492:3: note: Taking false branch
  if( (db->flags&SQLITE_ForeignKeys)==0 ) return;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122499:3: note: Loop condition is false. Execution continues on line 122602
  for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122602:3: note: Loop condition is true.  Entering loop body
  for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122607:9: note: 'aChange' is null
    if( aChange && fkParentIsModified(pTab, pFKey, aChange, bChngRowid)==0 ){
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122607:17: note: Left side of '&&' is false
    if( aChange && fkParentIsModified(pTab, pFKey, aChange, bChngRowid)==0 ){
                ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122611:9: note: Assuming field 'isDeferred' is not equal to 0
    if( !pFKey->isDeferred && !(db->flags & SQLITE_DeferFKs)
        ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122611:28: note: Left side of '&&' is false
    if( !pFKey->isDeferred && !(db->flags & SQLITE_DeferFKs)
                           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122620:9: note: Value assigned to 'pIdx'
    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122620:9: note: Assuming the condition is false
    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122620:5: note: Taking false branch
    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122629:9: note: Assuming 'pSrc' is non-null
    if( pSrc ){
        ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122629:5: note: Taking true branch
    if( pSrc ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122636:11: note: 'regNew' is equal to 0
      if( regNew!=0 ){
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122636:7: note: Taking false branch
      if( regNew!=0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122639:11: note: Assuming 'regOld' is not equal to 0
      if( regOld!=0 ){
          ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122639:7: note: Taking true branch
      if( regOld!=0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122641:44: note: Passing value via 4th parameter 'pIdx'
        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);
                                           ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122641:9: note: Calling 'fkScanChildren'
        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122176:7: note: 'nIncr' is >= 0
  if( nIncr<0 ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122176:3: note: Taking false branch
  if( nIncr<0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122189:12: note: Assuming 'i' is < field 'nCol'
  for(i=0; i<pFKey->nCol; i++){
           ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122189:3: note: Loop condition is true.  Entering loop body
  for(i=0; i<pFKey->nCol; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122196:12: note: Assuming 'pIdx' is null
    iCol = pIdx ? pIdx->aiColumn[i] : -1;
           ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122196:12: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122198:12: note: Assuming 'aiCol' is null
    iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
           ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122198:12: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122189:12: note: Assuming 'i' is >= field 'nCol'
  for(i=0; i<pFKey->nCol; i++){
           ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122189:3: note: Loop condition is false. Execution continues on line 122220
  for(i=0; i<pFKey->nCol; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122220:7: note: Assuming 'pTab' is equal to field 'pFrom'
  if( pTab==pFKey->pFrom && nIncr>0 ){
      ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122220:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122220:29: note: 'nIncr' is > 0
  if( pTab==pFKey->pFrom && nIncr>0 ){
                            ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122220:3: note: Taking true branch
  if( pTab==pFKey->pFrom && nIncr>0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122224:9: note: Assuming the condition is false
    if( HasRowid(pTab) ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122224:5: note: Taking false branch
    if( HasRowid(pTab) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122231:18: note: Access to field 'nKeyCol' results in a dereference of a null pointer (loaded from variable 'pIdx')
      for(i=0; i<pIdx->nKeyCol; i++){
                 ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122245:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sNameContext, 0, sizeof(NameContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122245:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sNameContext, 0, sizeof(NameContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122934:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy((char *)pStep->zTarget, zFrom, nFrom);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122934:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy((char *)pStep->zTarget, zFrom, nFrom);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122965:21: warning: Access to field 'op' results in a dereference of a null pointer (loaded from variable 'pStep') [clang-analyzer-core.NullDereference]
          pStep->op = TK_DELETE;
                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118625:7: note: Assuming field 'nErr' is 0
  if( pParse->nErr || db->mallocFailed ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118625:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118625:23: note: Assuming field 'mallocFailed' is 0
  if( pParse->nErr || db->mallocFailed ){
                      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118625:3: note: Taking false branch
  if( pParse->nErr || db->mallocFailed ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118637:7: note: 'pTab' is not equal to null
  if( pTab==0 )  goto delete_from_cleanup;
      ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118637:3: note: Taking false branch
  if( pTab==0 )  goto delete_from_cleanup;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118644:12: note: Assuming field 'pSelect' is equal to null
  isView = pTab->pSelect!=0;
           ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118649:14: note: 'pTrigger' is null
  bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);
             ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118649:14: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118667:7: note: Assuming the condition is false
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118667:3: note: Taking false branch
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118671:40: note: 'pTrigger' is null
  if( sqlite3IsReadOnly(pParse, pTab, (pTrigger?1:0)) ){
                                       ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118671:40: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118671:3: note: Taking false branch
  if( sqlite3IsReadOnly(pParse, pTab, (pTrigger?1:0)) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118679:7: note: 'rcauth' is not equal to SQLITE_DENY
  if( rcauth==SQLITE_DENY ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118679:3: note: Taking false branch
  if( rcauth==SQLITE_DENY ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118688:3: note: Loop condition is false. Execution continues on line 118694
  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118694:7: note: 'isView' is 0
  if( isView ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118694:3: note: Taking false branch
  if( isView ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118701:7: note: 'v' is not equal to null
  if( v==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118701:3: note: Taking false branch
  if( v==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118704:7: note: Assuming field 'nested' is not equal to 0
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118704:3: note: Taking false branch
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118711:7: note: 'isView' is 0
  if( isView ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118711:3: note: Taking false branch
  if( isView ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118726:3: note: Taking false branch
  if( sqlite3ResolveExprNames(&sNC, pWhere) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118733:7: note: Assuming the condition is false
  if( (db->flags & SQLITE_CountRows)!=0
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118734:4: note: Left side of '&&' is false
   && !pParse->nested
   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118754:7: note: 'rcauth' is equal to SQLITE_OK
  if( rcauth==SQLITE_OK
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118754:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118755:7: note: 'pWhere' is not equal to null
   && pWhere==0
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118756:4: note: Left side of '&&' is false
   && !bComplex
   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118779:9: note: Assuming the condition is false
    if( sNC.ncFlags & NC_VarSelect ) bComplex = 1;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118779:5: note: Taking false branch
    if( sNC.ncFlags & NC_VarSelect ) bComplex = 1;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118780:13: note: 'bComplex' is 0
    wcf |= (bComplex ? 0 : WHERE_ONEPASS_MULTIROW);
            ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118780:13: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118781:9: note: Assuming the condition is false
    if( HasRowid(pTab) ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118781:5: note: Taking false branch
    if( HasRowid(pTab) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118809:9: note: Assuming 'pWInfo' is not equal to null
    if( pWInfo==0 ) goto delete_from_cleanup;
        ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118809:5: note: Taking false branch
    if( pWInfo==0 ) goto delete_from_cleanup;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118813:9: note: Assuming 'eOnePass' is equal to ONEPASS_SINGLE
    if( eOnePass!=ONEPASS_SINGLE ) sqlite3MultiWrite(pParse);
        ^~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118813:5: note: Taking false branch
    if( eOnePass!=ONEPASS_SINGLE ) sqlite3MultiWrite(pParse);
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118814:9: note: Assuming the condition is false
    if( sqlite3WhereUsesDeferredSeek(pWInfo) ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118814:5: note: Taking false branch
    if( sqlite3WhereUsesDeferredSeek(pWInfo) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118819:9: note: 'memCnt' is 0
    if( memCnt ){
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118819:5: note: Taking false branch
    if( memCnt ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118824:9: note: 'pPk' is non-null
    if( pPk ){
        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118824:5: note: Taking true branch
    if( pPk ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118825:16: note: Assuming 'i' is >= 'nPk'
      for(i=0; i<nPk; i++){
               ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118825:7: note: Loop condition is false. Execution continues on line 118830
      for(i=0; i<nPk; i++){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118836:9: note: 'eOnePass' is not equal to ONEPASS_OFF
    if( eOnePass!=ONEPASS_OFF ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118836:5: note: Taking true branch
    if( eOnePass!=ONEPASS_OFF ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118842:11: note: Assuming 'aToOpen' is not equal to null
      if( aToOpen==0 ){
          ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118842:7: note: Taking false branch
      if( aToOpen==0 ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118848:11: note: Assuming the condition is false
      if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iTabCur] = 0;
          ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118848:7: note: Taking false branch
      if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iTabCur] = 0;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118849:11: note: Assuming the condition is false
      if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iTabCur] = 0;
          ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118849:7: note: Taking false branch
      if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iTabCur] = 0;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118850:11: note: Assuming 'addrEphOpen' is 0
      if( addrEphOpen ) sqlite3VdbeChangeToNoop(v, addrEphOpen);
          ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118850:7: note: Taking false branch
      if( addrEphOpen ) sqlite3VdbeChangeToNoop(v, addrEphOpen);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118873:10: note: 'isView' is 0
    if( !isView ){
         ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118873:5: note: Taking true branch
    if( !isView ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118875:11: note: 'eOnePass' is not equal to ONEPASS_MULTI
      if( eOnePass==ONEPASS_MULTI ){
          ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118875:7: note: Taking false branch
      if( eOnePass==ONEPASS_MULTI ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118883:11: note: 'eOnePass' is not equal to ONEPASS_MULTI
      if( eOnePass==ONEPASS_MULTI ){
          ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118883:7: note: Taking false branch
      if( eOnePass==ONEPASS_MULTI ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118891:9: note: 'eOnePass' is not equal to ONEPASS_OFF
    if( eOnePass!=ONEPASS_OFF ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118891:5: note: Taking true branch
    if( eOnePass!=ONEPASS_OFF ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118893:12: note: Field 'nModuleArg' is 0
      if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17837:35: note: expanded from macro 'IsVirtual'
#  define IsVirtual(X)      ((X)->nModuleArg)
                                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118893:11: note: Left side of '&&' is true
      if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118893:31: note: Assuming the condition is false
      if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){
                              ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118893:7: note: Taking false branch
      if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118914:9: note: Field 'nModuleArg' is 0
    if( IsVirtual(pTab) ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17837:35: note: expanded from macro 'IsVirtual'
#  define IsVirtual(X)      ((X)->nModuleArg)
                                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118914:5: note: Taking false branch
    if( IsVirtual(pTab) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118930:20: note: Assuming field 'nested' is not equal to 0
      int count = (pParse->nested==0);    /* True to count changes */
                   ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:118931:7: note: Calling 'sqlite3GenerateRowDelete'
      sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119055:12: note: '?' condition is false
  opSeek = HasRowid(pTab) ? OP_NotExists : OP_NotFound;
           ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:25: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119056:7: note: 'eMode' is not equal to ONEPASS_OFF
  if( eMode==ONEPASS_OFF ){
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119056:3: note: Taking false branch
  if( eMode==ONEPASS_OFF ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119064:45: note: Left side of '||' is true
  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){
                                            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119081:17: note: Assuming 'iCol' is >= field 'nCol'
    for(iCol=0; iCol<pTab->nCol; iCol++){
                ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119081:5: note: Loop condition is false. Execution continues on line 119091
    for(iCol=0; iCol<pTab->nCol; iCol++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119104:5: note: Taking false branch
    if( addrStart<sqlite3VdbeCurrentAddr(v) ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119128:7: note: Assuming field 'pSelect' is not equal to null
  if( pTab->pSelect==0 ){
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119128:3: note: Taking false branch
  if( pTab->pSelect==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:119148:3: note: Calling 'sqlite3FkActions'
  sqlite3FkActions(pParse, pTab, 0, iOld, 0, 0);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122998:7: note: Assuming the condition is true
  if( pParse->db->flags&SQLITE_ForeignKeys ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122998:3: note: Taking true branch
  if( pParse->db->flags&SQLITE_ForeignKeys ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123000:5: note: Loop condition is true.  Entering loop body
    for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123001:11: note: 'aChange' is equal to null
      if( aChange==0 || fkParentIsModified(pTab, pFKey, aChange, bChngRowid) ){
          ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123001:22: note: Left side of '||' is true
      if( aChange==0 || fkParentIsModified(pTab, pFKey, aChange, bChngRowid) ){
                     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123002:25: note: Calling 'fkActionTrigger'
        Trigger *pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122806:7: note: Assuming 'action' is not equal to OE_Restrict
  if( action==OE_Restrict && (db->flags & SQLITE_DeferFKs) ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122806:27: note: Left side of '&&' is false
  if( action==OE_Restrict && (db->flags & SQLITE_DeferFKs) ){
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122811:7: note: Assuming 'action' is not equal to OE_None
  if( action!=OE_None && !pTrigger ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122811:7: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122811:26: note: Assuming 'pTrigger' is null
  if( action!=OE_None && !pTrigger ){
                         ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122811:3: note: Taking true branch
  if( action!=OE_None && !pTrigger ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122816:5: note: 'pStep' initialized to a null pointer value
    TriggerStep *pStep = 0;        /* First (only) step of trigger program */
    ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122823:5: note: Taking false branch
    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) return 0;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122826:5: note: Loop condition is true.  Entering loop body
    for(i=0; i<pFKey->nCol; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122834:18: note: 'aiCol' is null
      iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
                 ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122834:18: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122839:31: note: 'pIdx' is null
                   pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zName);
                              ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122839:31: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122859:11: note: 'pChanges' is null
      if( pChanges ){
          ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122859:7: note: Taking false branch
      if( pChanges ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122871:11: note: 'action' is not equal to OE_Restrict
      if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122871:11: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122871:35: note: Assuming 'action' is equal to OE_Cascade
      if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){
                                  ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122871:35: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122871:57: note: 'pChanges' is null
      if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){
                                                        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122871:7: note: Taking false branch
      if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122826:5: note: Loop condition is false. Execution continues on line 122899
    for(i=0; i<pFKey->nCol; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122904:9: note: 'action' is not equal to OE_Restrict
    if( action==OE_Restrict ){
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122904:5: note: Taking false branch
    if( action==OE_Restrict ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122931:9: note: 'pTrigger' is null
    if( pTrigger ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122931:5: note: Taking false branch
    if( pTrigger ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122946:5: note: Assuming field 'bDisable' is not equal to 0
    EnableLookaside;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17001:21: note: expanded from macro 'EnableLookaside'
   db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue
                    ^~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122946:5: note: '?' condition is true
    EnableLookaside;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17001:21: note: expanded from macro 'EnableLookaside'
   db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue
                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122952:9: note: Assuming field 'mallocFailed' is not equal to 1
    if( db->mallocFailed==1 ){
        ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122952:5: note: Taking false branch
    if( db->mallocFailed==1 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122959:5: note: Control jumps to 'case 10:'  at line 122963
    switch( action ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122964:14: note: 'pChanges' is null
        if( !pChanges ){
             ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122964:9: note: Taking true branch
        if( !pChanges ){
        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:122965:21: note: Access to field 'op' results in a dereference of a null pointer (loaded from variable 'pStep')
          pStep->op = TK_DELETE;
          ~~~~~     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123958:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sNC, 0, sizeof(sNC));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123958:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sNC, 0, sizeof(sNC));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124463:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124463:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:126056:45: warning: Access to field 'tnum' results in a dereference of a null pointer (loaded from variable 'pSrcIdx') [clang-analyzer-core.NullDereference]
    sqlite3VdbeAddOp3(v, OP_OpenRead, iSrc, pSrcIdx->tnum, iDbSrc);
                                            ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125766:7: note: Assuming 'pSelect' is not equal to null
  if( pSelect==0 ){
      ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125766:3: note: Taking false branch
  if( pSelect==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125769:7: note: Assuming field 'pWith' is null
  if( pParse->pWith || pSelect->pWith ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125769:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125769:24: note: Assuming field 'pWith' is null
  if( pParse->pWith || pSelect->pWith ){
                       ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125769:3: note: Taking false branch
  if( pParse->pWith || pSelect->pWith ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125775:7: note: Calling 'sqlite3TriggerList'
  if( sqlite3TriggerList(pParse, pDest) ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:139727:7: note: Assuming field 'disableTriggers' is 0
  if( pParse->disableTriggers ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:139727:3: note: Taking false branch
  if( pParse->disableTriggers ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:139733:3: note: Loop condition is false. Execution continues on line 139767
  while( p ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:139767:3: note: Returning without writing to '->nModuleArg', which participates in a condition later
  return pList;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:139767:3: note: Returning without writing to '->pCheck', which participates in a condition later
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:139767:3: note: Returning without writing to '->pIndex', which participates in a condition later
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125775:7: note: Returning from 'sqlite3TriggerList'
  if( sqlite3TriggerList(pParse, pDest) ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125775:7: note: Assuming the condition is false
  if( sqlite3TriggerList(pParse, pDest) ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125775:3: note: Taking false branch
  if( sqlite3TriggerList(pParse, pDest) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125779:7: note: Assuming field 'nModuleArg' is 0
  if( IsVirtual(pDest) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17837:29: note: expanded from macro 'IsVirtual'
#  define IsVirtual(X)      ((X)->nModuleArg)
                            ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125779:3: note: Taking false branch
  if( IsVirtual(pDest) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125783:7: note: Assuming 'onError' is not equal to OE_Default
  if( onError==OE_Default ){
      ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125783:3: note: Taking false branch
  if( onError==OE_Default ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125788:7: note: Assuming field 'nSrc' is equal to 1
  if( pSelect->pSrc->nSrc!=1 ){
      ^~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125788:3: note: Taking false branch
  if( pSelect->pSrc->nSrc!=1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125791:7: note: Assuming field 'pSelect' is null
  if( pSelect->pSrc->a[0].pSelect ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125791:3: note: Taking false branch
  if( pSelect->pSrc->a[0].pSelect ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125794:7: note: Assuming field 'pWhere' is null
  if( pSelect->pWhere ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125794:3: note: Taking false branch
  if( pSelect->pWhere ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125797:7: note: Assuming field 'pOrderBy' is null
  if( pSelect->pOrderBy ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125797:3: note: Taking false branch
  if( pSelect->pOrderBy ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125802:7: note: Assuming field 'pGroupBy' is null
  if( pSelect->pGroupBy ){
      ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125802:3: note: Taking false branch
  if( pSelect->pGroupBy ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125805:7: note: Assuming field 'pLimit' is null
  if( pSelect->pLimit ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125805:3: note: Taking false branch
  if( pSelect->pLimit ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125808:7: note: Assuming field 'pPrior' is null
  if( pSelect->pPrior ){
      ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125808:3: note: Taking false branch
  if( pSelect->pPrior ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125811:7: note: Assuming the condition is false
  if( pSelect->selFlags & SF_Distinct ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125811:3: note: Taking false branch
  if( pSelect->selFlags & SF_Distinct ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125816:7: note: Assuming field 'nExpr' is equal to 1
  if( pEList->nExpr!=1 ){
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125816:3: note: Taking false branch
  if( pEList->nExpr!=1 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125820:7: note: Assuming field 'op' is equal to TK_ASTERISK
  if( pEList->a[0].pExpr->op!=TK_ASTERISK ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125820:3: note: Taking false branch
  if( pEList->a[0].pExpr->op!=TK_ASTERISK ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125830:7: note: Assuming 'pSrc' is not equal to null
  if( pSrc==0 ){
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125830:3: note: Taking false branch
  if( pSrc==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125833:7: note: Assuming 'pSrc->tnum' is not equal to 'pDest->tnum'
  if( pSrc->tnum==pDest->tnum && pSrc->pSchema==pDest->pSchema ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125833:31: note: Left side of '&&' is false
  if( pSrc->tnum==pDest->tnum && pSrc->pSchema==pDest->pSchema ){
                              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125837:7: note: Assuming the condition is false
  if( HasRowid(pDest)!=HasRowid(pSrc) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125837:24: note: Assuming the condition is false
  if( HasRowid(pDest)!=HasRowid(pSrc) ){
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125837:3: note: Taking false branch
  if( HasRowid(pDest)!=HasRowid(pSrc) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125841:7: note: Assuming field 'nModuleArg' is 0
  if( IsVirtual(pSrc) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17837:29: note: expanded from macro 'IsVirtual'
#  define IsVirtual(X)      ((X)->nModuleArg)
                            ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125841:3: note: Taking false branch
  if( IsVirtual(pSrc) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125845:7: note: Assuming field 'pSelect' is null
  if( pSrc->pSelect ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125845:3: note: Taking false branch
  if( pSrc->pSelect ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125848:7: note: Assuming 'pDest->nCol' is equal to 'pSrc->nCol'
  if( pDest->nCol!=pSrc->nCol ){
      ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125848:3: note: Taking false branch
  if( pDest->nCol!=pSrc->nCol ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125851:7: note: Assuming 'pDest->iPKey' is equal to 'pSrc->iPKey'
  if( pDest->iPKey!=pSrc->iPKey ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125851:3: note: Taking false branch
  if( pDest->iPKey!=pSrc->iPKey ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125854:12: note: Assuming 'i' is >= field 'nCol'
  for(i=0; i<pDest->nCol; i++){
           ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125854:3: note: Loop condition is false. Execution continues on line 125918
  for(i=0; i<pDest->nCol; i++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125918:3: note: Loop condition is false. Execution continues on line 125937
  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125937:7: note: Assuming field 'pCheck' is null
  if( pDest->pCheck && sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1) ){
      ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125937:21: note: Left side of '&&' is false
  if( pDest->pCheck && sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1) ){
                    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125949:7: note: Assuming the condition is false
  if( (db->flags & SQLITE_ForeignKeys)!=0 && pDest->pFKey!=0 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125949:43: note: Left side of '&&' is false
  if( (db->flags & SQLITE_ForeignKeys)!=0 && pDest->pFKey!=0 ){
                                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125953:7: note: Assuming the condition is false
  if( (db->flags & SQLITE_CountRows)!=0 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125953:3: note: Taking false branch
  if( (db->flags & SQLITE_CountRows)!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125973:3: note: Calling 'sqlite3OpenTable'
  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123097:21: note: 'opcode' is equal to OP_OpenWrite
                   (opcode==OP_OpenWrite)?1:0, pTab->zName);
                    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123097:20: note: '?' condition is true
                   (opcode==OP_OpenWrite)?1:0, pTab->zName);
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123098:7: note: Assuming the condition is false
  if( HasRowid(pTab) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123098:3: note: Taking false branch
  if( HasRowid(pTab) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:123102:18: note: Value assigned to field 'pIndex', which participates in a condition later
    Index *pPk = sqlite3PrimaryKeyIndex(pTab);
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125973:3: note: Returning from 'sqlite3OpenTable'
  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125975:7: note: Assuming the condition is false
  if( (db->mDbFlags & DBFLAG_Vacuum)==0 && (
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125975:41: note: Left side of '&&' is false
  if( (db->mDbFlags & DBFLAG_Vacuum)==0 && (
                                        ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:126001:3: note: Taking false branch
  if( HasRowid(pSrc) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:126050:3: note: Loop condition is true.  Entering loop body
  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:126052:9: note: Value assigned to 'pSrcIdx'
    for(pSrcIdx=pSrc->pIndex; ALWAYS(pSrcIdx); pSrcIdx=pSrcIdx->pNext){
        ^~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:126052:31: note: Assuming pointer value is null
    for(pSrcIdx=pSrc->pIndex; ALWAYS(pSrcIdx); pSrcIdx=pSrcIdx->pNext){
                              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13946:25: note: expanded from macro 'ALWAYS'
# define ALWAYS(X)      (X)
                        ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:126052:5: note: Loop condition is false. Execution continues on line 126055
    for(pSrcIdx=pSrc->pIndex; ALWAYS(pSrcIdx); pSrcIdx=pSrcIdx->pNext){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:126056:45: note: Access to field 'tnum' results in a dereference of a null pointer (loaded from variable 'pSrcIdx')
    sqlite3VdbeAddOp3(v, OP_OpenRead, iSrc, pSrcIdx->tnum, iDbSrc);
                                            ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:127523:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zAltEntry, "sqlite3_", 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:127523:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zAltEntry, "sqlite3_", 8);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:127532:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zAltEntry+iEntry, "_init", 6);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:127532:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zAltEntry+iEntry, "_init", 6);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:127569:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:127569:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:129908:11: warning: Value stored to 'x' is never read [clang-analyzer-deadcode.DeadStores]
          x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);
          ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:129908:11: note: Value stored to 'x' is never read
          x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);
          ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:130804:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(pTab, 0, sizeof(PragmaVtab));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:130804:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(pTab, 0, sizeof(PragmaVtab));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:130875:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pCsr, 0, sizeof(PragmaVtabCursor));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:130875:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pCsr, 0, sizeof(PragmaVtabCursor));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131333:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(meta, 0, sizeof(meta));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131333:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(meta, 0, sizeof(meta));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131700:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sParse, 0, PARSE_HDR_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131700:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sParse, 0, PARSE_HDR_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131701:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:131701:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:132739:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pKI->aSortFlags, 0, pKI->nKeyField); /* Makes OP_Jump testable */
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:132739:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pKI->aSortFlags, 0, pKI->nKeyField); /* Makes OP_Jump testable */
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:133460:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&p[1], 0, nExtra);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:133460:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&p[1], 0, nExtra);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:134243:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:134243:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:134259:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&pCol->zName[n+1], zType, m+1);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:134259:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&pCol->zName[n+1], zType, m+1);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:134502:11: warning: Value stored to 'pSetup' during its initialization is never read [clang-analyzer-deadcode.DeadStores]
  Select *pSetup = p->pPrior;   /* The setup query */
          ^~~~~~   ~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:134502:11: note: Value stored to 'pSetup' during its initialization is never read
  Select *pSetup = p->pPrior;   /* The setup query */
          ^~~~~~   ~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:134586:3: warning: Value stored to 'pFirstRec' is never read [clang-analyzer-deadcode.DeadStores]
  pFirstRec = p;
  ^           ~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:134586:3: note: Value stored to 'pFirstRec' is never read
  pFirstRec = p;
  ^           ~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:135698:11: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memset(&ifNullRow, 0, sizeof(ifNullRow));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:135698:11: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
          memset(&ifNullRow, 0, sizeof(ifNullRow));
          ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:135813:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:135813:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:135900:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:135900:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136347:15: warning: Access to field 'pSrc' results in a dereference of a null pointer (loaded from variable 'pSub') [clang-analyzer-core.NullDereference]
    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */
              ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136089:7: note: Assuming the condition is false
  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17330:42: note: expanded from macro 'OptimizationDisabled'
#define OptimizationDisabled(db, mask)  (((db)->dbOptFlags&(mask))!=0)
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136089:3: note: Taking false branch
  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136098:7: note: Assuming field 'pWin' is null
  if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136098:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136098:18: note: Assuming field 'pWin' is null
  if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */
                 ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136098:3: note: Taking false branch
  if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136108:7: note: Assuming field 'pLimit' is null
  if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136108:20: note: Left side of '&&' is false
  if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136109:13: note: Field 'pLimit' is null
  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   /* Restriction (14) */
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136109:20: note: Left side of '&&' is false
  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   /* Restriction (14) */
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136110:7: note: Assuming the condition is false
  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136110:38: note: Left side of '&&' is false
  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){
                                     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136113:7: note: Assuming field 'nSrc' is not equal to 0
  if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136113:3: note: Taking false branch
  if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136114:7: note: Assuming the condition is false
  if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (4)  */
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136114:3: note: Taking false branch
  if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (4)  */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136115:13: note: Field 'pLimit' is null
  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136115:20: note: Left side of '&&' is false
  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136118:7: note: Assuming field 'pOrderBy' is null
  if( p->pOrderBy && pSub->pOrderBy ){
      ^~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136118:19: note: Left side of '&&' is false
  if( p->pOrderBy && pSub->pOrderBy ){
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136121:7: note: Assuming 'isAgg' is 0
  if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136121:13: note: Left side of '&&' is false
  if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136122:13: note: Field 'pLimit' is null
  if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136122:20: note: Left side of '&&' is false
  if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136123:13: note: Field 'pLimit' is null
  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136123:20: note: Left side of '&&' is false
  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136126:7: note: Assuming the condition is false
  if( pSub->selFlags & (SF_Recursive) ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136126:3: note: Taking false branch
  if( pSub->selFlags & (SF_Recursive) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136150:7: note: Assuming the condition is false
  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136150:3: note: Taking false branch
  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136175:7: note: Assuming field 'pPrior' is null
  if( pSub->pPrior ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136175:3: note: Taking false branch
  if( pSub->pPrior ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136229:3: note: Calling 'sqlite3DbFree'
  sqlite3DbFree(db, pSubitem->zDatabase);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28231:7: note: Assuming 'p' is null
  if( p ) sqlite3DbFreeNN(db, p);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28231:3: note: Taking false branch
  if( p ) sqlite3DbFreeNN(db, p);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28232:1: note: Returning without writing to 'db->mallocFailed', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136229:3: note: Returning from 'sqlite3DbFree'
  sqlite3DbFree(db, pSubitem->zDatabase);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136230:3: note: Calling 'sqlite3DbFree'
  sqlite3DbFree(db, pSubitem->zName);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28231:7: note: Assuming 'p' is null
  if( p ) sqlite3DbFreeNN(db, p);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28231:3: note: Taking false branch
  if( p ) sqlite3DbFreeNN(db, p);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28232:1: note: Returning without writing to 'db->mallocFailed', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136230:3: note: Returning from 'sqlite3DbFree'
  sqlite3DbFree(db, pSubitem->zName);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136231:3: note: Calling 'sqlite3DbFree'
  sqlite3DbFree(db, pSubitem->zAlias);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28231:7: note: Assuming 'p' is null
  if( p ) sqlite3DbFreeNN(db, p);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28231:3: note: Taking false branch
  if( p ) sqlite3DbFreeNN(db, p);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28232:1: note: Returning without writing to 'db->mallocFailed', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136231:3: note: Returning from 'sqlite3DbFree'
  sqlite3DbFree(db, pSubitem->zAlias);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136271:3: note: Loop condition is false. Execution continues on line 136302
  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136302:3: note: Calling 'sqlite3DbFree'
  sqlite3DbFree(db, aCsrMap);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28231:7: note: 'p' is null
  if( p ) sqlite3DbFreeNN(db, p);
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28231:3: note: Taking false branch
  if( p ) sqlite3DbFreeNN(db, p);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:28232:1: note: Returning without writing to 'db->mallocFailed', which participates in a condition later
}
^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136302:3: note: Returning from 'sqlite3DbFree'
  sqlite3DbFree(db, aCsrMap);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136303:7: note: Assuming field 'mallocFailed' is 0
  if( db->mallocFailed ){
      ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136303:3: note: Taking false branch
  if( db->mallocFailed ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136315:14: note: Assuming field 'pTab' is equal to null
  if( ALWAYS(pSubitem->pTab!=0) ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:13946:26: note: expanded from macro 'ALWAYS'
# define ALWAYS(X)      (X)
                         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136315:3: note: Taking false branch
  if( ALWAYS(pSubitem->pTab!=0) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136343:3: note: Loop condition is true.  Entering loop body
  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136351:9: note: 'pParent' is equal to 'p'
    if( pParent==p ){
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136351:5: note: Taking true branch
    if( pParent==p ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136370:9: note: Assuming 'nSubSrc' is <= 1
    if( nSubSrc>1 ){
        ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136370:5: note: Taking false branch
    if( nSubSrc>1 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136379:14: note: Assuming 'i' is >= 'nSubSrc'
    for(i=0; i<nSubSrc; i++){
             ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136379:5: note: Loop condition is false. Execution continues on line 136386
    for(i=0; i<nSubSrc; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136400:9: note: Assuming field 'pOrderBy' is null
    if( pSub->pOrderBy && (pParent->selFlags & SF_NoopOrderBy)==0 ){
        ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136400:24: note: Left side of '&&' is false
    if( pSub->pOrderBy && (pParent->selFlags & SF_NoopOrderBy)==0 ){
                       ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136421:9: note: 'isLeftJoin' is <= 0
    if( isLeftJoin>0 ){
        ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136421:5: note: Taking false branch
    if( isLeftJoin>0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136424:9: note: Assuming 'pWhere' is non-null
    if( pWhere ){
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136424:5: note: Taking true branch
    if( pWhere ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136425:11: note: Assuming field 'pWhere' is non-null
      if( pParent->pWhere ){
          ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136425:7: note: Taking true branch
      if( pParent->pWhere ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136431:9: note: Assuming field 'mallocFailed' is not equal to 0
    if( db->mallocFailed==0 ){
        ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136431:5: note: Taking false branch
    if( db->mallocFailed==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136452:15: note: Field 'pLimit' is null
    if( pSub->pLimit ){
              ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136452:5: note: Taking false branch
    if( pSub->pLimit ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136459:14: note: 'i' is >= 'nSubSrc'
    for(i=0; i<nSubSrc; i++){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136459:5: note: Loop condition is false. Execution continues on line 136343
    for(i=0; i<nSubSrc; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136343:52: note: Null pointer value stored to 'pSub'
  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
                                                   ^~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136343:3: note: Loop condition is true.  Entering loop body
  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136347:15: note: Access to field 'pSrc' results in a dereference of a null pointer (loaded from variable 'pSub')
    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */
              ^~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136384:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136384:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136719:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&w, 0, sizeof(w));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:136719:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&w, 0, sizeof(w));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:137086:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&dummy, 0, sizeof(dummy));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:137086:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&dummy, 0, sizeof(dummy));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:137519:7: warning: Value stored to 'pTab' is never read [clang-analyzer-deadcode.DeadStores]
      pTab = pFrom->pTab;
      ^      ~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:137519:7: note: Value stored to 'pTab' is never read
      pTab = pFrom->pTab;
      ^      ~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:138128:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sWalker, 0, sizeof(sWalker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:138128:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sWalker, 0, sizeof(sWalker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:138396:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sSort, 0, sizeof(sSort));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:138396:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sSort, 0, sizeof(sSort));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:138959:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sNC, 0, sizeof(sNC));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:138959:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sNC, 0, sizeof(sNC));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:139564:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(z, argv[i], n);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:139564:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(z, argv[i], n);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140124:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(z, pName->z, pName->n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140124:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(z, pName->z, pName->n);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140595:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sSelect, 0, sizeof(sSelect));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140595:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sSelect, 0, sizeof(sSelect));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140596:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sFrom, 0, sizeof(sFrom));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140596:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sFrom, 0, sizeof(sFrom));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140609:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sNC, 0, sizeof(sNC));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140609:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sNC, 0, sizeof(sNC));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140803:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:140803:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141439:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sContext, 0, sizeof(sContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141439:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sContext, 0, sizeof(sContext));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141522:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(aToOpen, 1, nIdx+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141522:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(aToOpen, 1, nIdx+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141527:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141527:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141672:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(aToOpen, 1, nIdx+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:141672:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(aToOpen, 1, nIdx+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:142538:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:142538:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sNC, 0, sizeof(sNC));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:142568:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(sCol, 0, sizeof(sCol));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:142568:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(sCol, 0, sizeof(sCol));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:142693:14: warning: Access to field 'iDataCur' results in a dereference of a null pointer (loaded from variable 'pUpsert') [clang-analyzer-core.NullDereference]
  iDataCur = pUpsert->iDataCur;
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124675:14: note: Assuming 'regOldData' is equal to 0
  isUpdate = regOldData!=0;
             ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124686:7: note: Assuming the condition is false
  if( HasRowid(pTab) ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:17864:26: note: expanded from macro 'HasRowid'
#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124686:3: note: Taking false branch
  if( HasRowid(pTab) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124700:7: note: Assuming the condition is false
  if( pTab->tabFlags & TF_HasNotNull ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124700:3: note: Taking false branch
  if( pTab->tabFlags & TF_HasNotNull ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124801:7: note: Assuming field 'pCheck' is null
  if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124801:20: note: Left side of '&&' is false
  if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){
                   ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124875:7: note: Assuming 'pUpsert' is null
  if( pUpsert ){
      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124875:3: note: Taking false branch
  if( pUpsert ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124951:7: note: Assuming the condition is false
  if( (db->flags & (SQLITE_RecTriggers|SQLITE_ForeignKeys))==0 ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124951:3: note: Taking false branch
  if( (db->flags & (SQLITE_RecTriggers|SQLITE_ForeignKeys))==0 ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124957:9: note: Assuming the condition is false
    if( db->flags&SQLITE_RecTriggers ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124957:5: note: Taking false branch
    if( db->flags&SQLITE_RecTriggers ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124964:9: note: 'regTrigCnt' is 0
    if( regTrigCnt ){
        ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124964:5: note: Taking false branch
    if( regTrigCnt ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124978:7: note: Assuming 'pkChng' is 0
  if( pkChng && pPk==0 ){
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124978:14: note: Left side of '&&' is false
  if( pkChng && pPk==0 ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125125:14: note: Calling 'indexIteratorFirst'
  for(pIdx = indexIteratorFirst(&sIdxIter, &ix);
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124517:14: note: Field 'eType' is 0
  if( pIter->eType ){
             ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124517:3: note: Taking false branch
  if( pIter->eType ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124522:5: note: Returning without writing to 'pIter->u.lx.pIdx', which participates in a condition later
    return pIter->u.lx.pIdx;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:124522:5: note: Returning pointer, which participates in a condition later
    return pIter->u.lx.pIdx;
    ^~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125125:14: note: Returning from 'indexIteratorFirst'
  for(pIdx = indexIteratorFirst(&sIdxIter, &ix);
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125125:3: note: Loop condition is true.  Entering loop body
  for(pIdx = indexIteratorFirst(&sIdxIter, &ix);
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125135:9: note: Assuming the condition is false
    if( aRegIdx[ix]==0 ) continue;  /* Skip indices that do not change */
        ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125135:5: note: Taking false branch
    if( aRegIdx[ix]==0 ) continue;  /* Skip indices that do not change */
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125136:9: note: 'pUpsert' is null
    if( pUpsert ){
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125136:5: note: Taking false branch
    if( pUpsert ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125143:9: note: 'bAffinityDone' is equal to 0
    if( bAffinityDone==0 ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125143:5: note: Taking true branch
    if( bAffinityDone==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125152:9: note: Assuming field 'pPartIdxWhere' is null
    if( pIdx->pPartIdxWhere ){
        ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125152:5: note: Taking false branch
    if( pIdx->pPartIdxWhere ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125164:14: note: Assuming 'i' is >= field 'nColumn'
    for(i=0; i<pIdx->nColumn; i++){
             ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125164:5: note: Loop condition is false. Execution continues on line 125183
    for(i=0; i<pIdx->nColumn; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125196:9: note: 'isUpdate' is 0
    if( isUpdate && pPk==pIdx && pkChng==0 ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125196:18: note: Left side of '&&' is false
    if( isUpdate && pPk==pIdx && pkChng==0 ){
                 ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125203:9: note: Assuming 'onError' is not equal to OE_None
    if( onError==OE_None ){
        ^~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125203:5: note: Taking false branch
    if( onError==OE_None ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125207:9: note: Assuming 'overrideError' is equal to OE_Default
    if( overrideError!=OE_Default ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125207:5: note: Taking false branch
    if( overrideError!=OE_Default ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125209:15: note: Assuming 'onError' is not equal to OE_Default
    }else if( onError==OE_Default ){
              ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125209:11: note: Taking false branch
    }else if( onError==OE_Default ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125214:9: note: 'pUpsertClause' is null
    if( pUpsertClause ){
        ^~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125214:5: note: Taking false branch
    if( pUpsertClause ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125233:10: note: 'ix' is equal to 0
    if( (ix==0 && pIdx->pNext==0)                   /* Condition 3 */
         ^~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125233:10: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125233:19: note: Assuming field 'pNext' is not equal to null
    if( (ix==0 && pIdx->pNext==0)                   /* Condition 3 */
                  ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125234:6: note: Left side of '&&' is false
     && pPk==pIdx                                   /* Condition 2 */
     ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125253:12: note: Assuming 'pIdx' is not equal to 'pPk'
    regR = pIdx==pPk ? regIdx : sqlite3GetTempRange(pParse, nPkField);
           ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125253:12: note: '?' condition is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125254:9: note: 'isUpdate' is 0
    if( isUpdate || onError==OE_Replace ){
        ^~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125254:9: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125254:21: note: Assuming 'onError' is not equal to OE_Replace
    if( isUpdate || onError==OE_Replace ){
                    ^~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125254:5: note: Taking false branch
    if( isUpdate || onError==OE_Replace ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125312:5: note: Control jumps to 'case 6:'  at line 125323
    switch( onError ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125324:39: note: Passing null pointer value via 2nd parameter 'pUpsert'
        sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur+ix);
                                      ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:125324:9: note: Calling 'sqlite3UpsertDoUpdate'
        sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur+ix);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:142693:14: note: Access to field 'iDataCur' results in a dereference of a null pointer (loaded from variable 'pUpsert')
  iDataCur = pUpsert->iDataCur;
             ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:143209:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(zCopy, zName, nName+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:143209:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(zCopy, zName, nName+1);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:143768:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:143768:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:143879:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:143879:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:143967:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sParse, 0, sizeof(sParse));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:143967:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sParse, 0, sizeof(sParse));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:144307:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy((char*)&pNew[1], pDef->zName, sqlite3Strlen30(pDef->zName)+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:144307:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy((char*)&pNew[1], pDef->zName, sqlite3Strlen30(pDef->zName)+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146238:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(&pNew->orig, pExpr, sizeof(*pExpr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146238:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(&pNew->orig, pExpr, sizeof(*pExpr));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146312:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:146312:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:147191:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:147191:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:147194:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:147194:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:147676:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:147676:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:147692:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pTerm->eOperator, 0,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:147692:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pTerm->eOperator, 0,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:148258:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:148258:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:148285:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:148285:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:149390:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int)*2);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:149390:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int)*2);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:149414:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pDest->a, pSrc->a, pDest->n*sizeof(pDest->a[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:149414:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pDest->a, pSrc->a, pDest->n*sizeof(pDest->a[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151171:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151171:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151184:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(pTo, 0, WHERE_LOOP_XFER_SZ);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151184:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(pTo, 0, WHERE_LOOP_XFER_SZ);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151187:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pTo, pFrom, WHERE_LOOP_XFER_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151187:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pTo, pFrom, WHERE_LOOP_XFER_SZ);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151188:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pTo->aLTerm, pFrom->aLTerm, pTo->nLTerm*sizeof(pTo->aLTerm[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151188:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(pTo->aLTerm, pFrom->aLTerm, pTo->nLTerm*sizeof(pTo->aLTerm[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151233:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(p->pExpr, &p->orig, sizeof(p->orig));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:151233:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
    memcpy(p->pExpr, &p->orig, sizeof(p->orig));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:152237:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sPk, 0, sizeof(Index));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:152237:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sPk, 0, sizeof(Index));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:152510:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:152510:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:152814:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sSum, 0, sizeof(sSum));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:152814:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sSum, 0, sizeof(sSum));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:152893:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(&pNew->u, 0, sizeof(pNew->u));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:152893:7: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
      memset(&pNew->u, 0, sizeof(pNew->u));
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153312:19: warning: The result of the left shift is undefined due to shifting by '2147483647', which is greater or equal to the width of type 'Bitmask' [clang-analyzer-core.UndefinedBinaryOperatorResult]
      Bitmask m = MASKBIT(i) - 1;
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14962:35: note: expanded from macro 'MASKBIT'
#define MASKBIT(n)   (((Bitmask)1)<<(n))
                                  ^ ~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153056:7: note: Assuming 'nLoop' is 0
  if( nLoop && OptimizationDisabled(db, SQLITE_OrderByIdxJoin) ) return 0;
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153056:13: note: Left side of '&&' is false
  if( nLoop && OptimizationDisabled(db, SQLITE_OrderByIdxJoin) ) return 0;
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153060:7: note: Assuming the condition is false
  if( nOrderBy>BMS-1 ) return 0;  /* Cannot optimize overly large ORDER BYs */
      ^~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153060:3: note: Taking false branch
  if( nOrderBy>BMS-1 ) return 0;  /* Cannot optimize overly large ORDER BYs */
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153066:7: note: Assuming the condition is false
  if( wctrlFlags & (WHERE_ORDERBY_LIMIT|WHERE_ORDERBY_MAX|WHERE_ORDERBY_MIN) ){
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153066:3: note: Taking false branch
  if( wctrlFlags & (WHERE_ORDERBY_LIMIT|WHERE_ORDERBY_MAX|WHERE_ORDERBY_MIN) ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153069:16: note: 'isOrderDistinct' is 1
  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){
               ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153069:16: note: Left side of '&&' is true
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153069:35: note: Assuming 'obSat' is < 'obDone'
  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){
                                  ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153069:16: note: Left side of '&&' is true
  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){
               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153069:3: note: Loop condition is true.  Entering loop body
  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153070:9: note: 'iLoop' is <= 0
    if( iLoop>0 ) ready |= pLoop->maskSelf;
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153070:5: note: Taking false branch
    if( iLoop>0 ) ready |= pLoop->maskSelf;
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153071:9: note: 'iLoop' is >= 'nLoop'
    if( iLoop<nLoop ){
        ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153071:5: note: Taking false branch
    if( iLoop<nLoop ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153077:9: note: Assuming the condition is false
    if( pLoop->wsFlags & WHERE_VIRTUALTABLE ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153077:5: note: Taking false branch
    if( pLoop->wsFlags & WHERE_VIRTUALTABLE ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153082:15: note: Assuming the condition is false
    }else if( wctrlFlags & WHERE_DISTINCTBY ){
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153082:11: note: Taking false branch
    }else if( wctrlFlags & WHERE_DISTINCTBY ){
          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153092:14: note: Assuming 'i' is >= 'nOrderBy'
    for(i=0; i<nOrderBy; i++){
             ^~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153092:5: note: Loop condition is false. Execution continues on line 153123
    for(i=0; i<nOrderBy; i++){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153123:9: note: Assuming the condition is true
    if( (pLoop->wsFlags & WHERE_ONEROW)==0 ){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153123:5: note: Taking true branch
    if( (pLoop->wsFlags & WHERE_ONEROW)==0 ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153124:11: note: Assuming the condition is false
      if( pLoop->wsFlags & WHERE_IPK ){
          ^~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153124:7: note: Taking false branch
      if( pLoop->wsFlags & WHERE_IPK ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153128:17: note: Assuming the condition is false
      }else if( (pIndex = pLoop->u.btree.pIndex)==0 || pIndex->bUnordered ){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153128:17: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153128:56: note: Assuming field 'bUnordered' is 0
      }else if( (pIndex = pLoop->u.btree.pIndex)==0 || pIndex->bUnordered ){
                                                       ^~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153128:13: note: Taking false branch
      }else if( (pIndex = pLoop->u.btree.pIndex)==0 || pIndex->bUnordered ){
            ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153140:27: note: Assuming field 'onError' is equal to 0
        isOrderDistinct = IsUniqueIndex(pIndex)
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:18113:32: note: expanded from macro 'IsUniqueIndex'
#define IsUniqueIndex(X)      ((X)->onError!=OE_None)
                               ^~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153141:27: note: Left side of '&&' is false
                          && (pLoop->wsFlags & WHERE_SKIPSCAN)==0;
                          ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153149:16: note: Assuming 'j' is >= 'nColumn'
      for(j=0; j<nColumn; j++){
               ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153149:7: note: Loop condition is false. Execution continues on line 153287
      for(j=0; j<nColumn; j++){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153287:11: note: 'distinctColumns' is 0
      if( distinctColumns ){
          ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153287:7: note: Taking false branch
      if( distinctColumns ){
      ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153294:9: note: 'isOrderDistinct' is 0
    if( isOrderDistinct ){
        ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153294:5: note: Taking false branch
    if( isOrderDistinct ){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153069:16: note: 'isOrderDistinct' is 0
  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){
               ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153069:32: note: Left side of '&&' is false
  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){
                               ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153309:7: note: 'obSat' is not equal to 'obDone'
  if( obSat==obDone ) return (i8)nOrderBy;
      ^~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153309:3: note: Taking false branch
  if( obSat==obDone ) return (i8)nOrderBy;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153310:8: note: 'isOrderDistinct' is 0
  if( !isOrderDistinct ){
       ^~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153310:3: note: Taking true branch
  if( !isOrderDistinct ){
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153311:9: note: Value assigned to 'i'
    for(i=nOrderBy-1; i>0; i--){
        ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153311:23: note: Assuming 'i' is > 0
    for(i=nOrderBy-1; i>0; i--){
                      ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153311:5: note: Loop condition is true.  Entering loop body
    for(i=nOrderBy-1; i>0; i--){
    ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153312:19: note: The result of the left shift is undefined due to shifting by '2147483647', which is greater or equal to the width of type 'Bitmask'
      Bitmask m = MASKBIT(i) - 1;
                  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:14962:35: note: expanded from macro 'MASKBIT'
#define MASKBIT(n)   (((Bitmask)1)<<(n))
                                  ^ ~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153470:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(aFrom, 0, sizeof(aFrom[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153470:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(aFrom, 0, sizeof(aFrom[0]));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153483:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153483:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153671:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(pTo->aLoop, pFrom->aLoop, sizeof(WhereLoop*)*iLoop);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153671:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(pTo->aLoop, pFrom->aLoop, sizeof(WhereLoop*)*iLoop);
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153909:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:153909:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&w, 0, sizeof(w));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:154062:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sWLB, 0, sizeof(sWLB));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:154062:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sWLB, 0, sizeof(sWLB));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:154116:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pWInfo->nOBSat, 0,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:154116:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pWInfo->nOBSat, 0,
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:154118:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pWInfo->a[0], 0, sizeof(WhereLoop)+nTabList*sizeof(WhereLevel));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:154118:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&pWInfo->a[0], 0, sizeof(WhereLoop)+nTabList*sizeof(WhereLevel));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:154375:9: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memmove(&pWInfo->a[i], &pWInfo->a[i+1], nByte);
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:154375:9: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
        memmove(&pWInfo->a[i], &pWInfo->a[i+1], nByte);
        ^~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155723:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(pExpr, 0, sizeof(Expr));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155723:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(pExpr, 0, sizeof(Expr));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155780:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sWalker, 0, sizeof(Walker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155780:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sWalker, 0, sizeof(Walker));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155781:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&sRewrite, 0, sizeof(WindowRewrite));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155781:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&sRewrite, 0, sizeof(WindowRewrite));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155995:9: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(pTab, pTab2, sizeof(Table));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155995:9: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
        memcpy(pTab, pTab2, sizeof(Table));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155999:9: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memset(&w, 0, sizeof(w));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:155999:9: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
        memset(&w, 0, sizeof(w));
        ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:157710:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&s, 0, sizeof(WindowCodeArg));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:157710:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(&s, 0, sizeof(WindowCodeArg));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:158172:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(p->u.zToken, t.z, t.n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:158172:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(p->u.zToken, t.z, t.n);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:165378:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:165378:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:166905:13: warning: Although the value stored to 'nName' is used in the enclosing expression, the value is never actually read from 'nName' [clang-analyzer-deadcode.DeadStores]
   || (255<(nName = sqlite3Strlen30( zFunctionName)))
            ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:166905:13: note: Although the value stored to 'nName' is used in the enclosing expression, the value is never actually read from 'nName'
   || (255<(nName = sqlite3Strlen30( zFunctionName)))
            ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:167957:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(zFile, 0, 4);  /* 4-byte of 0x00 is the start of DB name marker */
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:167957:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(zFile, 0, 4);  /* 4-byte of 0x00 is the start of DB name marker */
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168049:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(zFile+iOut, 0, 4); /* end-of-options + empty journal filenames */
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168049:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(zFile+iOut, 0, 4); /* end-of-options + empty journal filenames */
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168131:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(zFile, 0, 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168131:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(zFile, 0, 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168134:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(zFile, zUri, nUri);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168134:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
      memcpy(zFile, zUri, nUri);
      ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168136:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(zFile+nUri, 0, 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168136:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
    memset(zFile+nUri, 0, 4);
    ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168161:10: warning: Array access (from variable 'zFilename') results in a null pointer dereference [clang-analyzer-core.NullDereference]
  while( zFilename[0] ){
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169526:19: note: Calling 'sqlite3_uri_parameter'
  const char *z = sqlite3_uri_parameter(zFilename, zParam);
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169490:7: note: Assuming 'zFilename' is not equal to null
  if( zFilename==0 || zParam==0 ) return 0;
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169490:7: note: Left side of '||' is false
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169490:23: note: Assuming 'zParam' is not equal to null
  if( zFilename==0 || zParam==0 ) return 0;
                      ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169490:3: note: Taking false branch
  if( zFilename==0 || zParam==0 ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169492:10: note: Calling 'uriParameter'
  return uriParameter(zFilename, zParam);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168160:3: note: Null pointer value stored to 'zFilename'
  zFilename += sqlite3Strlen30(zFilename) + 1;
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168161:10: note: Array access (from variable 'zFilename') results in a null pointer dereference
  while( zFilename[0] ){
         ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168265:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:168265:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169422:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p, z, n+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169422:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  memcpy(p, z, n+1);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169451:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(p, 0, 4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169451:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  memset(p, 0, 4);
  ^~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169502:10: warning: Array access (from variable 'zFilename') results in a null pointer dereference [clang-analyzer-core.NullDereference]
  while( zFilename[0] && (N--)>0 ){
         ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169499:7: note: Assuming 'zFilename' is not equal to null
  if( zFilename==0 || N<0 ) return 0;
      ^~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169499:7: note: Left side of '||' is false
Suppressed 502 warnings (502 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
Found compiler error(s).
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169499:23: note: Assuming 'N' is >= 0
  if( zFilename==0 || N<0 ) return 0;
                      ^~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169499:3: note: Taking false branch
  if( zFilename==0 || N<0 ) return 0;
  ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169501:3: note: Null pointer value stored to 'zFilename'
  zFilename += sqlite3Strlen30(zFilename) + 1;
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169502:10: note: Array access (from variable 'zFilename') results in a null pointer dereference
  while( zFilename[0] && (N--)>0 ){
         ^~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169550:10: warning: Array access (from variable 'zFilename') results in a null pointer dereference [clang-analyzer-core.NullDereference]
  while( zFilename[0] ){
         ^
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169560:15: note: Calling 'sqlite3_filename_journal'
  zFilename = sqlite3_filename_journal(zFilename);
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169549:3: note: Null pointer value stored to 'zFilename'
  zFilename += sqlite3Strlen30(zFilename) + 1;
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:\Users\nitzr\source\repos\HexCpp\HexCpp\Database\SQLite\sqlite3.c:169550:10: note: Array access (from variable 'zFilename') results in a null pointer dereference
  while( zFilename[0] ){
         ^~~~~~~~~
